--- a/solver-core/src/linalg/kkt.rs
+++ b/solver-core/src/linalg/kkt.rs
@@ -398,6 +398,11 @@
 
                 for _ in 0..refine_iters {
                     symm_matvec_upper(kkt, &sol_perm, &mut kx);
+                    if self.static_reg != 0.0 {
+                        for i in 0..kkt_dim {
+                            kx[i] += self.static_reg * sol_perm[i];
+                        }
+                    }
                     for i in 0..kkt_dim {
                         res[i] = rhs_perm[i] - kx[i];
                     }

--- a/solver-core/src/ipm/mod.rs
+++ b/solver-core/src/ipm/mod.rs
@@ -160,7 +160,7 @@
         compute_residuals(&scaled_prob, &state, &mut residuals);
 
         // Check termination
-        if let Some(term_status) = check_termination(&scaled_prob, &state, &residuals, mu, iter, &criteria) {
+        if let Some(term_status) = check_termination(&prob, &scaling, &state, iter, &criteria) {
             status = term_status;
             break;
         }

--- a/solver-core/src/ipm/termination.rs
+++ b/solver-core/src/ipm/termination.rs
@@ -5,8 +5,12 @@
 //! - Primal infeasibility: τ → 0 with b^T z < 0
 //! - Dual infeasibility: τ → 0 with q^T x < 0
 //! - Numerical errors: NaN, factorization failure, stalled progress
-
-use super::hsde::{HsdeState, HsdeResiduals};
+//!
+//! IMPORTANT: All termination checks should be done on **unscaled** data
+//! (after undoing Ruiz scaling). See design doc §16.
+
+use super::hsde::HsdeState;
+use crate::presolve::ruiz::RuizScaling;
 use crate::problem::{ProblemData, SolveStatus};
 
 /// Termination criteria.
@@ -48,19 +52,31 @@
     }
 }
 
+#[inline]
+fn inf_norm(v: &[f64]) -> f64 {
+    v.iter()
+        .map(|x| x.abs())
+        .fold(0.0_f64, f64::max)
+}
+
+#[inline]
+fn dot(a: &[f64], b: &[f64]) -> f64 {
+    debug_assert_eq!(a.len(), b.len());
+    a.iter().zip(b.iter()).map(|(ai, bi)| ai * bi).sum()
+}
+
 /// Check termination conditions.
 ///
 /// Returns `Some(status)` if solver should terminate, `None` otherwise.
 pub fn check_termination(
     prob: &ProblemData,
+    scaling: &RuizScaling,
     state: &HsdeState,
-    residuals: &HsdeResiduals,
-    mu: f64,
     iter: usize,
     criteria: &TerminationCriteria,
 ) -> Option<SolveStatus> {
     // Check for NaN
-    if state.tau.is_nan() || state.kappa.is_nan() || mu.is_nan() {
+    if state.tau.is_nan() || state.kappa.is_nan() {
         return Some(SolveStatus::NumericalError);
     }
 
@@ -75,117 +91,112 @@
         return Some(SolveStatus::MaxIters);
     }
 
-    // Unscale solution by τ
+    // τ ≈ 0: check infeasibility certificates (design doc §16.2).
     if state.tau < criteria.tau_min {
-        // τ ≈ 0: Check for infeasibility certificates
-        return check_infeasibility(prob, state, criteria);
-    }
-
-    // Compute unscaled quantities
-    let x_bar: Vec<f64> = state.x.iter().map(|xi| xi / state.tau).collect();
-    let _s_bar: Vec<f64> = state.s.iter().map(|si| si / state.tau).collect();
-    let z_bar: Vec<f64> = state.z.iter().map(|zi| zi / state.tau).collect();
-
-    // Compute primal objective: 0.5 * x^T P x + q^T x
-    let mut primal_obj = 0.0;
-
+        return check_infeasibility(prob, scaling, state, criteria);
+    }
+
+    // Unscale solution by τ and undo Ruiz scaling (design doc §16).
+    let inv_tau = 1.0 / state.tau;
+    let x_bar_scaled: Vec<f64> = state.x.iter().map(|xi| xi * inv_tau).collect();
+    let s_bar_scaled: Vec<f64> = state.s.iter().map(|si| si * inv_tau).collect();
+    let z_bar_scaled: Vec<f64> = state.z.iter().map(|zi| zi * inv_tau).collect();
+
+    let x_bar = scaling.unscale_x(&x_bar_scaled);
+    let s_bar = scaling.unscale_s(&s_bar_scaled);
+    let z_bar = scaling.unscale_z(&z_bar_scaled);
+
+    let n = prob.num_vars();
+    let m = prob.num_constraints();
+    debug_assert_eq!(x_bar.len(), n);
+    debug_assert_eq!(s_bar.len(), m);
+    debug_assert_eq!(z_bar.len(), m);
+
+    // Residuals on unscaled data:
+    //   r_p = A x̄ + s̄ - b
+    //   r_d = P x̄ + A^T z̄ + q
+    let mut r_p = s_bar.clone();
+    for i in 0..m {
+        r_p[i] -= prob.b[i];
+    }
+    for (&val, (row, col)) in prob.A.iter() {
+        r_p[row] += val * x_bar[col];
+    }
+
+    let mut p_x = vec![0.0; n];
     if let Some(ref p) = prob.P {
-        // x^T P x
-        let mut px = vec![0.0; prob.num_vars()];
-        for col in 0..prob.num_vars() {
+        for col in 0..n {
             if let Some(col_view) = p.outer_view(col) {
                 for (row, &val) in col_view.iter() {
-                    px[row] += val * x_bar[col];
-                    if row != col {
-                        px[col] += val * x_bar[row]; // Symmetric
+                    if row == col {
+                        p_x[row] += val * x_bar[col];
+                    } else {
+                        p_x[row] += val * x_bar[col];
+                        p_x[col] += val * x_bar[row];
                     }
                 }
             }
         }
-        for i in 0..prob.num_vars() {
-            primal_obj += 0.5 * x_bar[i] * px[i];
-        }
-    }
-
-    // q^T x
-    for i in 0..prob.num_vars() {
-        primal_obj += prob.q[i] * x_bar[i];
-    }
-
-    // Compute dual objective: -b^T z (for LP) or -b^T z - 0.5 x^T P x (for QP)
-    // For QP: dual obj = -b^T z - 0.5 x^T P x (the quadratic term appears in both)
-    let mut dual_obj = 0.0;
-    for i in 0..prob.num_constraints() {
-        dual_obj -= prob.b[i] * z_bar[i];
-    }
-    // Add quadratic contribution for QP (dual objective includes -0.5 x^T P x)
-    if let Some(ref p) = prob.P {
-        let mut xpx = 0.0;
-        for col in 0..prob.num_vars() {
-            if let Some(col_view) = p.outer_view(col) {
-                for (row, &val) in col_view.iter() {
-                    if row == col {
-                        xpx += x_bar[row] * val * x_bar[col];
-                    } else {
-                        xpx += 2.0 * x_bar[row] * val * x_bar[col];
-                    }
-                }
-            }
-        }
-        dual_obj -= 0.5 * xpx;
-    }
-
-    // Compute residuals (unscaled)
-    let (rx_norm, rz_norm, _) = residuals.norms();
-
-    // Compute scaling factors for relative residuals
-    let b_norm = prob.b.iter().map(|x| x.abs()).fold(0.0_f64, f64::max).max(1.0);
-    let q_norm = prob.q.iter().map(|x| x.abs()).fold(0.0_f64, f64::max).max(1.0);
-
-    // Relative residuals (scaled by problem data norms)
-    let primal_res = rz_norm / (state.tau * b_norm);
-    let dual_res = rx_norm / (state.tau * q_norm);
+    }
+
+    let mut r_d = vec![0.0; n];
+    for i in 0..n {
+        r_d[i] = p_x[i] + prob.q[i];
+    }
+    for (&val, (row, col)) in prob.A.iter() {
+        r_d[col] += val * z_bar[row];
+    }
+
+    let rp_inf = inf_norm(&r_p);
+    let rd_inf = inf_norm(&r_d);
+
+    if !rp_inf.is_finite() || !rd_inf.is_finite() {
+        return Some(SolveStatus::NumericalError);
+    }
+
+    // Feasibility scaling (design doc §16.1).
+    let b_inf = inf_norm(&prob.b);
+    let q_inf = inf_norm(&prob.q);
+    let x_inf = inf_norm(&x_bar);
+    let s_inf = inf_norm(&s_bar);
+    let z_inf = inf_norm(&z_bar);
+
+    let primal_scale = (b_inf + x_inf + s_inf).max(1.0);
+    let dual_scale = (q_inf + x_inf + z_inf).max(1.0);
+
+    let primal_ok = rp_inf <= criteria.tol_feas * primal_scale;
+    let dual_ok = rd_inf <= criteria.tol_feas * dual_scale;
+
+    // Objectives on unscaled data (design doc §16).
+    let xpx = dot(&x_bar, &p_x);
+    let qtx = dot(&prob.q, &x_bar);
+    let btz = dot(&prob.b, &z_bar);
+
+    let primal_obj = 0.5 * xpx + qtx;
+    let dual_obj = -0.5 * xpx - btz;
+
     let gap = (primal_obj - dual_obj).abs();
 
-    // Compute relative gap: gap / max(|primal_obj|, |dual_obj|, 1)
-    let obj_scale = primal_obj.abs().max(dual_obj.abs()).max(1.0);
-    let gap_rel = gap / obj_scale;
-
-    // Primary optimality check: μ-based convergence
-    // When μ is very small, complementarity is satisfied. Check feasibility.
-    let mu_converged = mu < criteria.tol_gap;
-    let feas_ok = primal_res < criteria.tol_feas && dual_res < criteria.tol_feas;
-    let gap_ok = gap < criteria.tol_gap || gap_rel < criteria.tol_gap_rel;
-
-    // Optimal if: (feasible AND gap small) OR (μ very small AND reasonably feasible)
-    if feas_ok && gap_ok {
+    // Absolute gap scaling from design doc: max(1, min(|g_p|, |g_d|)).
+    let gap_scale_abs = primal_obj.abs().min(dual_obj.abs()).max(1.0);
+    let gap_ok_abs = gap <= criteria.tol_gap * gap_scale_abs;
+
+    // Relative gap fallback (often more stable when objectives are near zero).
+    let gap_scale_rel = primal_obj.abs().max(dual_obj.abs()).max(1.0);
+    let gap_rel = gap / gap_scale_rel;
+    let gap_ok = gap_ok_abs || gap_rel <= criteria.tol_gap_rel;
+
+    if primal_ok && dual_ok && gap_ok {
         return Some(SolveStatus::Optimal);
     }
 
-    // μ-based termination: if μ is very small, algorithm has converged
-    // Use relaxed feasibility check (10x tolerance)
-    if mu_converged {
-        let relaxed_feas = primal_res < 10.0 * criteria.tol_feas
-                        && dual_res < 10.0 * criteria.tol_feas;
-        if relaxed_feas {
-            return Some(SolveStatus::Optimal);
-        }
-    }
-
-    // Check for stalled progress with very small μ
-    if mu < criteria.min_progress && iter > 10 {
-        // Consider this "solved" if residuals are reasonable (100x tolerance)
-        if primal_res < 100.0 * criteria.tol_feas && dual_res < 100.0 * criteria.tol_feas {
-            return Some(SolveStatus::Optimal);
-        }
-    }
-
     None
 }
 
-/// Check for infeasibility certificates when τ ≈ 0.
+/// Check for infeasibility certificates when τ ≈ 0 (design doc §16.2).
 fn check_infeasibility(
     prob: &ProblemData,
+    scaling: &RuizScaling,
     state: &HsdeState,
     criteria: &TerminationCriteria,
 ) -> Option<SolveStatus> {
@@ -193,21 +204,80 @@
         return None;
     }
 
-    // Check primal infeasibility: b^T z < 0
-    let btz: f64 = prob.b.iter().zip(state.z.iter()).map(|(bi, zi)| bi * zi).sum();
-
-    if btz < -1e-8 {
-        return Some(SolveStatus::PrimalInfeasible);
-    }
-
-    // Check dual infeasibility: q^T x < 0
-    let qtx: f64 = prob.q.iter().zip(state.x.iter()).map(|(qi, xi)| qi * xi).sum();
-
-    if qtx < -1e-8 {
-        return Some(SolveStatus::DualInfeasible);
-    }
-
-    // τ ≈ 0 but no clear certificate
+    // Use unnormalized variables (x, s, z) and undo Ruiz scaling.
+    let x = scaling.unscale_x(&state.x);
+    let s = scaling.unscale_s(&state.s);
+    let z = scaling.unscale_z(&state.z);
+
+    let n = prob.num_vars();
+    let m = prob.num_constraints();
+    debug_assert_eq!(x.len(), n);
+    debug_assert_eq!(s.len(), m);
+    debug_assert_eq!(z.len(), m);
+
+    let x_inf = inf_norm(&x);
+    let s_inf = inf_norm(&s);
+    let z_inf = inf_norm(&z);
+
+    // ----------------------------------------------------------------------
+    // Primal infeasibility certificate (typical pattern):
+    //  - b^T z < -eps_abs
+    //  - ||A^T z||_inf <= eps_rel * max(1, ||x||_inf + ||z||_inf) * |b^T z|
+    //  - z ∈ K* (not checked here yet)
+    // ----------------------------------------------------------------------
+    let btz = dot(&prob.b, &z);
+    if btz < -criteria.tol_infeas {
+        let mut atz = vec![0.0; n];
+        for (&val, (row, col)) in prob.A.iter() {
+            atz[col] += val * z[row];
+        }
+        let atz_inf = inf_norm(&atz);
+        let bound = criteria.tol_infeas * (x_inf + z_inf).max(1.0) * btz.abs();
+
+        if atz_inf <= bound {
+            return Some(SolveStatus::PrimalInfeasible);
+        }
+    }
+
+    // ----------------------------------------------------------------------
+    // Dual infeasibility certificate (typical pattern):
+    //  - q^T x < -eps_abs
+    //  - ||P x||_inf <= eps_rel * max(1, ||x||_inf) * |q^T x|
+    //  - ||A x + s||_inf <= eps_rel * max(1, ||x||_inf + ||s||_inf) * |q^T x|
+    //  - s ∈ K (not checked here yet)
+    // ----------------------------------------------------------------------
+    let qtx = dot(&prob.q, &x);
+    if qtx < -criteria.tol_infeas {
+        let mut p_x = vec![0.0; n];
+        if let Some(ref p) = prob.P {
+            for col in 0..n {
+                if let Some(col_view) = p.outer_view(col) {
+                    for (row, &val) in col_view.iter() {
+                        if row == col {
+                            p_x[row] += val * x[col];
+                        } else {
+                            p_x[row] += val * x[col];
+                            p_x[col] += val * x[row];
+                        }
+                    }
+                }
+            }
+        }
+        let p_x_inf = inf_norm(&p_x);
+        let px_bound = criteria.tol_infeas * x_inf.max(1.0) * qtx.abs();
+
+        let mut ax_s = s.clone();
+        for (&val, (row, col)) in prob.A.iter() {
+            ax_s[row] += val * x[col];
+        }
+        let ax_s_inf = inf_norm(&ax_s);
+        let axs_bound = criteria.tol_infeas * (x_inf + s_inf).max(1.0) * qtx.abs();
+
+        if p_x_inf <= px_bound && ax_s_inf <= axs_bound {
+            return Some(SolveStatus::DualInfeasible);
+        }
+    }
+
     Some(SolveStatus::NumericalError)
 }
 
@@ -215,42 +285,39 @@
 mod tests {
     use super::*;
     use crate::linalg::sparse;
+    use crate::problem::ConeSpec;
 
     #[test]
     fn test_termination_optimal() {
-        // Simple LP
+        // Simple equality-constrained LP:
+        //   min  x1 + x2
+        //   s.t. x1 + x2 = 1
         let prob = ProblemData {
             P: None,
             q: vec![1.0, 1.0],
             A: sparse::from_triplets(1, 2, vec![(0, 0, 1.0), (0, 1, 1.0)]),
             b: vec![1.0],
-            cones: vec![],
+            cones: vec![ConeSpec::Zero { dim: 1 }],
             var_bounds: None,
             integrality: None,
         };
 
-        // At optimality: primal obj = q'x = 1.0, dual obj = -b'z
-        // Strong duality: q'x = -b'z => 1.0 = -z => z = -1.0
+        // KKT point:
+        //  Ax = b, A^T z + q = 0, with z = -1.
         let state = HsdeState {
             x: vec![0.5, 0.5],
             s: vec![0.0],
-            z: vec![-1.0],  // Fixed: was 1.0, should be -1.0 for strong duality
+            z: vec![-1.0],
             tau: 1.0,
-            kappa: 1e-10,   // Near-complementarity (was 0.0)
-            xi: vec![0.5, 0.5],  // ξ = x/τ
-        };
-
-        let mut residuals = HsdeResiduals::new(2, 1);
-        // Make residuals small (near-optimal)
-        residuals.r_x = vec![1e-9, 1e-9];
-        residuals.r_z = vec![1e-9];
-        residuals.r_tau = 1e-9;
+            kappa: 1e-10,
+            xi: vec![0.5, 0.5],
+        };
 
         let criteria = TerminationCriteria::default();
-
-        let status = check_termination(&prob, &state, &residuals, 1e-9, 10, &criteria);
-
-        // Should detect optimality
+        let scaling = RuizScaling::identity(2, 1);
+
+        let status = check_termination(&prob, &scaling, &state, 10, &criteria);
+
         assert!(matches!(status, Some(SolveStatus::Optimal)));
     }
 
@@ -261,51 +328,54 @@
             q: vec![1.0],
             A: sparse::from_triplets(1, 1, vec![(0, 0, 1.0)]),
             b: vec![1.0],
-            cones: vec![],
+            cones: vec![ConeSpec::Zero { dim: 1 }],
             var_bounds: None,
             integrality: None,
         };
 
         let state = HsdeState::new(1, 1);
-        let residuals = HsdeResiduals::new(1, 1);
         let criteria = TerminationCriteria {
             max_iter: 50,
             ..Default::default()
         };
-
-        let status = check_termination(&prob, &state, &residuals, 1.0, 51, &criteria);
+        let scaling = RuizScaling::identity(1, 1);
+
+        let status = check_termination(&prob, &scaling, &state, 51, &criteria);
 
         assert!(matches!(status, Some(SolveStatus::MaxIters)));
     }
 
     #[test]
-    fn test_termination_primal_infeasible() {
-        // Primal infeasible problem (no x satisfies Ax = b, x >= 0)
+    fn test_termination_primal_infeasible_certificate() {
+        // Primal infeasible:
+        //   find s ∈ R_+ with s = -1  (impossible)
+        //
+        // Dual certificate:
+        //   z ∈ R_+, b^T z < 0, and A^T z = 0 (A is empty here).
         let prob = ProblemData {
             P: None,
-            q: vec![0.0],
-            A: sparse::from_triplets(1, 1, vec![(0, 0, 1.0)]),
-            b: vec![-1.0], // Infeasible for x >= 0
-            cones: vec![],
+            q: vec![],
+            A: sparse::from_triplets(1, 0, vec![]),
+            b: vec![-1.0],
+            cones: vec![ConeSpec::NonNeg { dim: 1 }],
             var_bounds: None,
             integrality: None,
         };
 
         let state = HsdeState {
-            x: vec![0.0],
+            x: vec![],
             s: vec![1.0],
-            z: vec![1.0], // z > 0
+            z: vec![1.0], // z >= 0
             tau: 1e-10,   // τ → 0
             kappa: 1.0,
-            xi: vec![0.0],  // ξ = x/τ (but x=0 anyway)
-        };
-
-        let residuals = HsdeResiduals::new(1, 1);
+            xi: vec![],
+        };
+
         let criteria = TerminationCriteria::default();
-
-        let status = check_termination(&prob, &state, &residuals, 1.0, 10, &criteria);
-
-        // Should detect primal infeasibility (b^T z = -1 * 1 = -1 < 0)
+        let scaling = RuizScaling::identity(0, 1);
+
+        let status = check_termination(&prob, &scaling, &state, 10, &criteria);
+
         assert!(matches!(status, Some(SolveStatus::PrimalInfeasible)));
     }
 }
