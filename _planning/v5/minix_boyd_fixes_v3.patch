diff -ruN /mnt/data/minix_repo_extracted_orig/solver-core/src/ipm/mod.rs /mnt/data/minix_repo_extracted/solver-core/src/ipm/mod.rs
--- /mnt/data/minix_repo_extracted_orig/solver-core/src/ipm/mod.rs	2026-01-03 21:43:27.756005593 +0000
+++ /mnt/data/minix_repo_extracted/solver-core/src/ipm/mod.rs	2026-01-03 21:39:09.224956946 +0000
@@ -77,20 +77,11 @@
 
     // Initialize KKT solver
     // For LPs (P=None) or very sparse QPs, use higher regularization to stabilize.
-    // The (1,1) block is only εI for LPs. With small ε, solving
-    //   [εI, A^T] [dx]   [rhs_x]
-    //   [A,  -(H)] [dz] = [rhs_z]
-    // gives dx ≈ rhs_x/ε, which blows up for small ε.
-    // Using ε=1e-4 provides stability while allowing good convergence.
-    let p_is_sparse = scaled_prob.P.as_ref().map_or(true, |p| {
-        p.nnz() < n / 2  // Less than 50% diagonal fill
-    });
-    let static_reg = if p_is_sparse {
-        settings.static_reg.max(1e-4)  // LP or sparse QP: use at least 1e-4
-    } else {
-        settings.static_reg.max(1e-6)  // Dense QP: use at least 1e-6
-    };
-
+    // The (1,1) block is εI for LPs. ε must be large enough to keep the KKT
+    // quasi-definite, but small enough not to cap attainable accuracy.
+    // Using a large ε (e.g. 1e-4) can cause dual feasibility to stall on
+    // ill-conditioned problems, so we keep the default floor small.
+    let static_reg = settings.static_reg.max(1e-8);
     let mut kkt = KktSolver::new(
         n,
         m,
diff -ruN /mnt/data/minix_repo_extracted_orig/solver-core/src/ipm/predcorr.rs /mnt/data/minix_repo_extracted/solver-core/src/ipm/predcorr.rs
--- /mnt/data/minix_repo_extracted_orig/solver-core/src/ipm/predcorr.rs	2026-01-03 21:43:27.756269724 +0000
+++ /mnt/data/minix_repo_extracted/solver-core/src/ipm/predcorr.rs	2026-01-03 21:40:52.890204068 +0000
@@ -264,40 +264,6 @@
         offset += dim;
     }
 
-    // Adaptive regularization: gently increase when near boundaries
-    // When min(s, z) < μ/100, the scaling can become ill-conditioned.
-    let conditioning_threshold = mu / 100.0;
-    let min_sz = s_min.min(z_min);
-    let needs_extra_reg = min_sz.is_finite() && min_sz < conditioning_threshold;
-    let base_reg = settings.static_reg.max(settings.dynamic_reg_min_pivot);
-    let extra_reg = if needs_extra_reg {
-        let denom = min_sz.max(1e-300);
-        let ratio = conditioning_threshold / denom;
-        let scale = ratio.sqrt().min(100.0);
-        (base_reg * scale).min(1e-4)
-    } else {
-        0.0
-    };
-
-    if settings.verbose && extra_reg > 0.0 {
-        eprintln!(
-            "extra_reg={:.2e} (s_min={:.2e}, z_min={:.2e}, mu={:.2e})",
-            extra_reg, s_min, z_min, mu
-        );
-    }
-
-    // Apply extra regularization by modifying the scaling
-    if extra_reg > 0.0 {
-        for block in scaling.iter_mut() {
-            if let ScalingBlock::Diagonal { d } = block {
-                for di in d.iter_mut() {
-                    // Add regularization to H directly (H_reg = H + extra_reg * I)
-                    *di += extra_reg;
-                }
-            }
-        }
-    }
-
     // ======================================================================
     // Step 2: Factor KKT system
     // ======================================================================
diff -ruN /mnt/data/minix_repo_extracted_orig/solver-core/src/problem.rs /mnt/data/minix_repo_extracted/solver-core/src/problem.rs
--- /mnt/data/minix_repo_extracted_orig/solver-core/src/problem.rs	2026-01-03 21:43:27.758130605 +0000
+++ /mnt/data/minix_repo_extracted/solver-core/src/problem.rs	2026-01-03 21:42:40.551892985 +0000
@@ -185,10 +185,10 @@
             tol_gap: 1e-8,
             tol_infeas: 1e-8,
             ruiz_iters: 10,
-            static_reg: 1e-9,
-            dynamic_reg_min_pivot: 1e-7,
+            static_reg: 1e-8,
+            dynamic_reg_min_pivot: 1e-13,
             threads: 0,  // Auto-detect
-            kkt_refine_iters: 1,
+            kkt_refine_iters: 2,
             mcc_iters: 0,
             centrality_beta: 0.1,
             centrality_gamma: 10.0,
diff -ruN /mnt/data/minix_repo_extracted_orig/solver-core/src/scaling/nt.rs /mnt/data/minix_repo_extracted/solver-core/src/scaling/nt.rs
--- /mnt/data/minix_repo_extracted_orig/solver-core/src/scaling/nt.rs	2026-01-03 21:43:27.758465268 +0000
+++ /mnt/data/minix_repo_extracted/solver-core/src/scaling/nt.rs	2026-01-03 21:44:32.933712046 +0000
@@ -56,10 +56,17 @@
 
     // NT scaling for nonnegative orthant: H = diag(s/z)
     // This satisfies: H*z = s and H^{-1}*s = z.
+    //
+    // We guard against extreme dynamic ranges in s/z by clamping to a wide,
+    // but finite, interval. This avoids NaNs/Infs in the KKT assembly while
+    // still preserving the qualitative scaling.
     let d: Vec<f64> = s.iter().zip(z.iter())
-        .map(|(si, zi)| si / zi)
+        .map(|(si, zi)| {
+            let num = si.max(1e-300);
+            let den = zi.max(1e-300);
+            (num / den).clamp(1e-300, 1e300)
+        })
         .collect();
-
     Ok(ScalingBlock::Diagonal { d })
 }
 
