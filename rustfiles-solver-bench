# This file is an auto-generated concatenation of a codebase.
#
# Structure:
#
# INDEX
#   '<line_in_FILE_INDEX> <path>'
#   Jump to that line number to find the corresponding FILE_INDEX entry for the file.
#
# FILE_INDEX
#   '<file_start_line> <path>'
#     '  <symbol_line> <kind> <name>'
#   The first line for a file tells you where the file's content starts in this combined output.
#   The indented lines list classes/functions (and similar symbols) with their line numbers.
#
# CONTENT
#   After the '----' separator, each file is emitted as:
#     '=== <path> ==='
#     <original file contents>
#
# Notes:
# - All line numbers refer to THIS combined file (not the original repository files).
# - Symbol extraction: Python uses AST; Rust/Swift use regex heuristics (best-effort).
# - Common generated/dependency/VCS artifacts are excluded; pass --include-tests to include tests.
INDEX
47 examples/boyd_diagnostic.rs
49 examples/comprehensive_cone_diagnostics.rs
53 examples/exp_cone_baseline.rs
57 examples/exp_cone_debug.rs
61 examples/exp_cone_interior_check.rs
63 examples/exp_cone_no_presolve.rs
66 examples/exp_cone_suite.rs
76 examples/exp_cone_timing.rs
80 examples/exp_cone_timing_proximity.rs
82 examples/exp_cone_trace.rs
85 examples/measure_cone_iterations.rs
88 src/comparison.rs
108 src/conic_benchmarks.rs
127 src/exp_cone_bench.rs
139 src/main.rs
161 src/maros_meszaros.rs
178 src/qps.rs
189 src/regression.rs
204 src/sdplib.rs
225 src/solver_choice.rs
228 src/test_problems.rs
FILE_INDEX
237 examples/boyd_diagnostic.rs
  243 fn main
284 examples/comprehensive_cone_diagnostics.rs
  291 fn exp_cone_trivial
  309 fn soc_problem
  335 fn main
418 examples/exp_cone_baseline.rs
  425 fn trivial
  442 fn cvxpy_style
  463 fn main
524 examples/exp_cone_debug.rs
  530 fn trivial
  547 fn trivial_multi
  579 fn main
612 examples/exp_cone_interior_check.rs
  617 fn main
681 examples/exp_cone_no_presolve.rs
  687 fn trivial
  703 fn main
728 examples/exp_cone_suite.rs
  736 mod bench_problems
  739 fn trivial
  756 fn cvxpy_style
  778 fn trivial_multi
  810 fn entropy_maximization
  850 fn kl_divergence
  894 fn log_sum_exp
  938 struct BenchResult
  947 fn main
1027 examples/exp_cone_timing.rs
  1034 fn exp_cone_trivial
  1053 fn exp_cone_cvxpy
  1085 fn main
1132 examples/exp_cone_timing_proximity.rs
  1135 fn main
1209 examples/exp_cone_trace.rs
  1215 fn trivial
  1236 fn main
1270 examples/measure_cone_iterations.rs
  1276 mod test_problems
  1278 fn main
1298 src/comparison.rs
  1314 struct SolverResults
  1323 impl SolverResults
  1325 fn new
  1335 fn save_json
  1345 fn load_json
  1355 struct SolverComparison
  1360 impl SolverComparison
  1362 fn new
  1367 fn all_problems
  1378 fn problem_map
  1383 fn is_solved
  1388 fn print_summary
  1418 fn print_win_matrix
  1482 fn print_performance_comparison
  1544 fn geom_mean
  1554 fn print_detailed_comparison
  1611 mod tests
  1615 fn make_test_result
  1630 fn test_win_matrix
1657 src/conic_benchmarks.rs
  1726 fn exp_cone_cvxpy_style
  1769 fn relative_entropy_simple
  1824 fn sdp_trace_minimization
  1895 fn sdp_maxcut
  1950 mod tests
  1954 fn test_exp_debug_trivial
  1991 fn test_exponential_cone_cvxpy
  2013 fn test_exponential_cone_simple
  2034 fn test_sdp_simple_psd_only
  2081 fn test_sdp_trace_minimization
  2100 fn test_sdp_maxcut_triangle
  2118 fn test_sdp_trace_minimization_4x4
  2136 fn test_sdp_trace_minimization_5x5
  2154 fn test_sdp_maxcut_path
  2175 fn test_sdp_maxcut_complete_4
  2198 fn test_sdp_maxcut_star
  2216 fn test_sdp_lovasz_theta
  2315 fn test_sdp_min_eigenvalue
2428 src/exp_cone_bench.rs
  2449 fn entropy_maximization
  2521 fn kl_divergence
  2593 fn log_sum_exp
  2654 fn portfolio_exp_utility
  2722 struct BenchResult
  2733 fn run_exp_cone_benchmarks
  2824 fn print_benchmark_table
  2868 mod tests
  2872 fn test_entropy_maximization_small
  2892 fn test_kl_divergence_small
  2914 fn test_run_all_benchmarks
2924 src/main.rs
  2927 mod conic_benchmarks
  2928 mod exp_cone_bench
  2929 mod maros_meszaros
  2930 mod qps
  2931 mod regression
  2932 mod sdplib
  2933 mod solver_choice
  2934 mod test_problems
  2945 struct Cli
  2952 enum BenchmarkSuite
  2962 enum Commands
  3045 fn generate_random_lp
  3109 fn generate_portfolio_lp
  3148 fn run_benchmark
  3180 fn run_random_benchmarks
  3217 fn run_maros_meszaros
  3303 fn show_qps_info
  3347 fn run_regression_suite
  3490 fn run_exp_benchmarks
  3500 fn run_sdplib_benchmarks
  3700 fn main
3764 src/maros_meszaros.rs
  3804 fn mm_problem_names
  3809 fn inf_norm
  3816 fn dot
  3821 fn print_diagnostics
  3984 struct BenchmarkResult
  4007 struct BenchmarkSummary
  4029 fn get_cache_dir
  4034 fn find_local_qps
  4057 fn load_local_problem
  4066 fn download_qps
  4115 fn load_problem
  4126 fn run_single
  4220 fn run_full_suite
  4258 fn compute_summary
  4336 fn print_summary
  4361 fn print_results_table
4387 src/qps.rs
  4414 struct QpsProblem
  4443 impl QpsProblem
  4450 fn to_problem_data
  4619 fn to_socp_form
  4782 fn parse_qps
  5252 mod tests
  5258 fn test_simple_qp_conversion
  5283 fn write_temp_qps
  5291 fn test_fixed_width_parsing_with_spaces_in_names
  5324 fn test_fixed_width_row_type_position
5361 src/regression.rs
  5371 struct RegressionResult
  5390 struct PerfSummary
  5398 impl PerfSummary
  5399 fn empty
  5410 fn perf_summary
  5432 fn compare_perf_baseline
  5488 fn expected_behavior
  5501 fn run_regression_suite
  5893 fn run_case
  5959 fn run_socp_tests
  6105 fn synthetic_cases
  6143 fn expected_iterations
  6201 mod tests
  6206 fn regression_suite_smoke
6421 src/sdplib.rs
  6449 struct SdpaData
  6460 struct SdpaMatrix
  6466 struct SdpaEntry
  6474 enum SdpaForm
  6479 fn sdpa_form_from_env
  6493 fn parse_sdpa_sparse
  6584 fn sdpa_block_offsets
  6614 fn sdpa_to_conic
  6693 fn sdpa_to_conic_dual
  6743 fn sdpa_to_conic_selected
  6753 fn svec_index
  6769 fn svec_scale
  6783 fn load_sdpa_file
  6796 fn solve_sdpa
  6828 struct SdpaResult
  6838 fn sdplib_reference_values
  6951 mod tests
  6955 fn test_parse_simple_sdpa
  6983 fn test_sdpa_to_conic_simple
  7016 fn test_svec_index
7033 src/solver_choice.rs
  7040 enum SolverChoice
  7045 fn solve_with_choice
7056 src/test_problems.rs
  7063 struct TestProblem
  7077 fn build_syn_lp_nonneg
  7090 fn build_syn_soc_feas
  7113 fn synthetic_test_problems
  7137 fn maros_meszaros_problem_names
  7178 fn maros_meszaros_expected_failures
CONTENT
----
=== examples/boyd_diagnostic.rs ===
//! Diagnose BOYD1 and BOYD2 problems

use solver_core::{solve, SolverSettings};
use std::path::Path;

fn main() {
    println!("\n=== BOYD Problem Diagnostics ===\n");

    for name in &["BOYD1", "BOYD2"] {
        println!("Testing {}...", name);

        let prob = match maros_meszaros::load_problem(name) {
            Ok(p) => p,
            Err(e) => {
                println!("  Error loading: {:?}\n", e);
                continue;
            }
        };

        let settings = SolverSettings {
            verbose: false,
            max_iter: 30,
            tol_feas: 1e-8,
            tol_gap: 1e-8,
            ..Default::default()
        };

        match solve(&prob, &settings) {
            Ok(sol) => {
                println!("  Status: {:?}", sol.status);
                println!("  Iterations: {}", sol.info.iters);
                println!("  Objective: {:.6e}", sol.obj_val);
                println!("  Residuals:");
                println!("    primal_res: {:.6e}", sol.info.primal_res);
                println!("    dual_res:   {:.6e}", sol.info.dual_res);
                println!("    gap:        {:.6e}", sol.info.gap);
                println!("    mu:         {:.6e}", sol.info.mu);
            },
            Err(e) => {
                println!("  Error: {:?}", e);
            }
        }
        println!();
    }
}

=== examples/comprehensive_cone_diagnostics.rs ===
//! Comprehensive diagnostics for SOC, SDP, and Exp cone problems
//! Shows iteration 25-30 details for problematic cases

use solver_core::{solve, ConeSpec, ProblemData, SolverSettings, SolveStatus};
use solver_core::linalg::sparse;

fn exp_cone_trivial() -> ProblemData {
    // min x
    // s.t. s = [-x, 1, 1] ∈ K_exp
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let a = sparse::from_triplets(3, 1, triplets);
    let b = vec![0.0, 1.0, 1.0];
    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn soc_problem() -> ProblemData {
    // min t
    // s.t. ||(x1, x2)|| <= t, t >= 1
    let q = vec![1.0, 0.0, 0.0];  // min t
    let a = sparse::from_triplets(
        4,
        3,
        vec![
            (0, 0, -1.0), // -t + s1 = -1
            (1, 0, 1.0),  // t + s2 = 0 (SOC first)
            (2, 1, 1.0),  // x1 + s3 = 0
            (3, 2, 1.0),  // x2 + s4 = 0
        ],
    );
    let b = vec![-1.0, 0.0, 0.0, 0.0];
    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::NonNeg { dim: 1 }, ConeSpec::Soc { dim: 3 }],
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n");
    println!("================================================================================");
    println!("COMPREHENSIVE CONE DIAGNOSTICS - ITERATION 25-30 DETAILS");
    println!("================================================================================");
    println!();

    // Test Exp Cone
    println!("################################################################################");
    println!("## EXP CONE: Trivial Problem");
    println!("################################################################################");
    println!("Problem: min x s.t. s = [-x, 1, 1] ∈ K_exp");
    println!("Expected: x = 0, obj = 0");
    println!();

    let prob_exp = exp_cone_trivial();
    let settings_exp = SolverSettings {
        verbose: true,
        max_iter: 35,
        tol_feas: 1e-8,
        tol_gap: 1e-8,
        ..Default::default()
    };

    match solve(&prob_exp, &settings_exp) {
        Ok(sol) => {
            println!("\n--- FINAL RESULT ---");
            println!("Status: {:?}", sol.status);
            println!("Iterations: {}", sol.info.iters);
            println!("Objective: {:.10e}", sol.obj_val);
            println!("x = {:?}", sol.x);
            println!("Residuals:");
            println!("  primal_res: {:.6e}", sol.info.primal_res);
            println!("  dual_res:   {:.6e}", sol.info.dual_res);
            println!("  gap:        {:.6e}", sol.info.gap);
            println!("  mu:         {:.6e}", sol.info.mu);
        },
        Err(e) => println!("ERROR: {:?}", e),
    }

    println!();
    println!();

    // Test SOC
    println!("################################################################################");
    println!("## SOC: Simple SOCP Problem");
    println!("################################################################################");
    println!("Problem: min t s.t. ||(x1, x2)|| <= t, t >= 1");
    println!("Expected: t = 1, x1 = x2 = 0, obj = 1");
    println!();

    let prob_soc = soc_problem();
    let settings_soc = SolverSettings {
        verbose: true,
        max_iter: 35,
        tol_feas: 1e-8,
        tol_gap: 1e-8,
        ..Default::default()
    };

    match solve(&prob_soc, &settings_soc) {
        Ok(sol) => {
            println!("\n--- FINAL RESULT ---");
            println!("Status: {:?}", sol.status);
            println!("Iterations: {}", sol.info.iters);
            println!("Objective: {:.10e}", sol.obj_val);
            println!("x = {:?}", sol.x);
            println!("Residuals:");
            println!("  primal_res: {:.6e}", sol.info.primal_res);
            println!("  dual_res:   {:.6e}", sol.info.dual_res);
            println!("  gap:        {:.6e}", sol.info.gap);
            println!("  mu:         {:.6e}", sol.info.mu);
        },
        Err(e) => println!("ERROR: {:?}", e),
    }

    println!();
    println!();
    println!("================================================================================");
    println!("END OF DIAGNOSTICS");
    println!("================================================================================");
}

=== examples/exp_cone_baseline.rs ===
//! Baseline benchmark for exp cone improvements

use solver_core::{ConeSpec, ProblemData, SolverSettings, solve};
use solver_core::linalg::sparse;
use std::time::Instant;

fn trivial() -> ProblemData {
    let num_vars = 1;
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let A = sparse::from_triplets(3, num_vars, triplets);
    let b = vec![0.0, 1.0, 1.0];
    ProblemData {
        P: None,
        q,
        A,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn cvxpy_style() -> ProblemData {
    let num_vars = 3;
    let q = vec![1.0, 1.0, 1.0];
    let e = std::f64::consts::E;
    let triplets = vec![
        (0, 0, -1.0), (1, 1, -1.0), (2, 2, -1.0),
        (3, 1, 1.0), (4, 2, 1.0),
    ];
    let A = sparse::from_triplets(5, num_vars, triplets);
    let b = vec![0.0, 0.0, 0.0, 1.0, e];
    ProblemData {
        P: None,
        q,
        A,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }, ConeSpec::Zero { dim: 2 }],
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n{:=<80}", "");
    println!("EXPONENTIAL CONE BASELINE BENCHMARK");
    println!("{:=<80}\n", "");

    let problems = vec![
        ("trivial", trivial(), 50),
        ("cvxpy", cvxpy_style(), 200),
    ];

    println!("{:<20} {:>8} {:>12} {:>12} {:>10} {:>12}",
             "Problem", "Iters", "Time (ms)", "Objective", "µs/iter", "Status");
    println!("{:-<80}", "");

    let mut total_time = 0.0;

    for (name, prob, expected_iters) in problems {
        let mut settings = SolverSettings::default();
        settings.max_iter = expected_iters;
        settings.verbose = false;

        // Warmup
        let _ = solve(&prob, &settings);

        // Timed solve (average of 5 runs)
        let mut times = vec![];
        let mut iters = 0;
        let mut obj = 0.0;
        let mut status = solver_core::SolveStatus::MaxIters;

        for _ in 0..5 {
            let start = Instant::now();
            let result = solve(&prob, &settings).unwrap();
            let elapsed = start.elapsed().as_secs_f64() * 1000.0;
            times.push(elapsed);
            iters = result.info.iters;
            obj = result.obj_val;
            status = result.status;
        }

        let avg_time = times.iter().sum::<f64>() / times.len() as f64;
        let time_per_iter = (avg_time * 1000.0) / iters as f64;

        let status_str = match status {
            solver_core::SolveStatus::Optimal => "Optimal",
            solver_core::SolveStatus::AlmostOptimal => "AlmostOpt",
            solver_core::SolveStatus::MaxIters => "MaxIter",
            _ => "Other",
        };

        println!("{:<20} {:>8} {:>12.2} {:>12.4} {:>10.1} {:>12}",
                 name, iters, avg_time, obj, time_per_iter, status_str);

        total_time += avg_time;
    }

    println!("{:-<80}", "");
    println!("Total time: {:.2} ms\n", total_time);
    println!("{:=<80}\n", "");
}

=== examples/exp_cone_debug.rs ===
//! Debug exp cone multi-problem issues

use solver_core::{ConeSpec, ProblemData, SolverSettings, solve};
use solver_core::linalg::sparse;

fn trivial() -> ProblemData {
    let num_vars = 1;
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let a = sparse::from_triplets(3, num_vars, triplets);
    let b = vec![0.0, 1.0, 1.0];
    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn trivial_multi(n: usize) -> ProblemData {
    let num_vars = n;
    let q = vec![1.0; num_vars];

    // Each exp cone has 3 rows, constraint: s_i = [-x_i, 1, 1] ∈ K_exp
    let mut triplets = Vec::new();
    for i in 0..n {
        let row_base = 3 * i;
        triplets.push((row_base, i, -1.0));
    }

    let num_rows = 3 * n;
    let a = sparse::from_triplets(num_rows, num_vars, triplets);

    let mut b = Vec::new();
    for _ in 0..n {
        b.push(0.0);  // s[3i] = 0
        b.push(1.0);  // s[3i+1] = 1
        b.push(1.0);  // s[3i+2] = 1
    }

    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::Exp { count: n }],
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n=== Testing Trivial Problem (max_iter=1000, tol=1e-8) ===");
    let prob1 = trivial();
    let mut settings1 = SolverSettings::default();
    settings1.max_iter = 1000;
    settings1.verbose = false;

    match solve(&prob1, &settings1) {
        Ok(sol) => {
            println!("Status: {:?}, Iters: {}, Obj: {:.4e}", sol.status, sol.info.iters, sol.obj_val);
            println!("primal_res: {:.4e}, dual_res: {:.4e}, gap: {:.4e}, mu: {:.4e}",
                     sol.info.primal_res, sol.info.dual_res, sol.info.gap, sol.info.mu);
        },
        Err(e) => println!("Error: {:?}", e),
    }

    println!("\n=== Testing Trivial-Multi-2 (max_iter=1000, tol=1e-8) ===");
    let prob2 = trivial_multi(2);
    let mut settings2 = SolverSettings::default();
    settings2.max_iter = 1000;
    settings2.verbose = false;

    match solve(&prob2, &settings2) {
        Ok(sol) => {
            println!("Status: {:?}, Iters: {}, Obj: {:.4e}", sol.status, sol.info.iters, sol.obj_val);
            println!("primal_res: {:.4e}, dual_res: {:.4e}, gap: {:.4e}, mu: {:.4e}",
                     sol.info.primal_res, sol.info.dual_res, sol.info.gap, sol.info.mu);
        },
        Err(e) => println!("Error: {:?}", e),
    }

}

=== examples/exp_cone_interior_check.rs ===
//! Check if exp cone initialization is truly interior

use solver_core::cones::{ExpCone, ConeKernel};

fn main() {
    println!("\n=== Exp Cone Interior Check ===\n");

    let cone = ExpCone::new(1);
    let mut s = vec![0.0; 3];
    let mut z = vec![0.0; 3];

    // Get unit initialization
    cone.unit_initialization(&mut s, &mut z);

    println!("Initialization values:");
    println!("  s = [{:.6}, {:.6}, {:.6}]", s[0], s[1], s[2]);
    println!("  z = [{:.6}, {:.6}, {:.6}]", z[0], z[1], z[2]);
    println!();

    // Check if interior
    let s_interior = cone.is_interior_primal(&s);
    let z_interior = cone.is_interior_dual(&z);

    println!("Interior checks:");
    println!("  s is interior (primal): {}", s_interior);
    println!("  z is interior (dual):   {}", z_interior);
    println!();

    // Compute ψ for primal cone
    let x = s[0];
    let y = s[1];
    let z_val = s[2];
    if y > 0.0 && z_val > 0.0 {
        let psi = y * (z_val / y).ln() - x;
        println!("Primal cone check:");
        println!("  x = {:.6}", x);
        println!("  y = {:.6}", y);
        println!("  z = {:.6}", z_val);
        println!("  ψ = y*log(z/y) - x = {:.6}", psi);
        println!("  ψ > 0? {} (required for interior)", psi > 0.0);
        println!("  exp(x/y) = {:.6}", (x/y).exp());
        println!("  y*exp(x/y) = {:.6}", y * (x/y).exp());
        println!("  y*exp(x/y) < z? {} (equivalent condition)", y * (x/y).exp() < z_val);
    }
    println!();

    // Compute barrier value
    let barrier = cone.barrier_value(&s);
    println!("Barrier value: {:.6}", barrier);
    println!("  Is finite? {}", barrier.is_finite());
    println!();

    // Check a simple direction
    let ds = vec![0.1, 0.0, 0.0];  // Small step in x direction
    let alpha = cone.step_to_boundary_primal(&s, &ds);
    println!("Step to boundary test:");
    println!("  ds = [{:.6}, {:.6}, {:.6}]", ds[0], ds[1], ds[2]);
    println!("  alpha = {:.6}", alpha);
    println!();

    // Try the step
    let s_new = vec![s[0] + 0.5 * ds[0], s[1] + 0.5 * ds[1], s[2] + 0.5 * ds[2]];
    let s_new_interior = cone.is_interior_primal(&s_new);
    println!("After 50% step:");
    println!("  s_new = [{:.6}, {:.6}, {:.6}]", s_new[0], s_new[1], s_new[2]);
    println!("  is interior? {}", s_new_interior);
}

=== examples/exp_cone_no_presolve.rs ===
//! Test exp cone WITHOUT presolve

use solver_core::{solve, ConeSpec, ProblemData, SolverSettings};
use solver_core::linalg::sparse;

fn trivial() -> ProblemData {
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let a = sparse::from_triplets(3, 1, triplets);
    let b = vec![0.0, 1.0, 1.0];
    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n=== Exp Cone WITHOUT Presolve ===\n");

    let prob = trivial();
    let settings = SolverSettings {
        verbose: true,
        max_iter: 50,
        tol_feas: 1e-8,
        tol_gap: 1e-8,
        ruiz_iters: 0,  // Disable Ruiz
        ..Default::default()
    };

    match solve(&prob, &settings) {
        Ok(sol) => {
            println!("Status: {:?}", sol.status);
            println!("Iterations: {}", sol.info.iters);
            println!("x = {:?}", sol.x);
            println!("s = {:?}", sol.s);
            println!("z = {:?}", sol.z);
        },
        Err(e) => println!("ERROR: {:?}", e),
    }
}

=== examples/exp_cone_suite.rs ===
//! Comprehensive exponential cone benchmark suite

use solver_core::{ConeSpec, ProblemData, SolverSettings, solve, SolveStatus};
use solver_core::linalg::sparse;
use std::time::Instant;

// Re-use benchmark problem generators
mod bench_problems {
    use super::*;

    pub fn trivial() -> ProblemData {
        let num_vars = 1;
        let q = vec![1.0];
        let triplets = vec![(0, 0, -1.0)];
        let A = sparse::from_triplets(3, num_vars, triplets);
        let b = vec![0.0, 1.0, 1.0];
        ProblemData {
            P: None,
            q,
            A,
            b,
            cones: vec![ConeSpec::Exp { count: 1 }],
            var_bounds: None,
            integrality: None,
        }
    }

    pub fn cvxpy_style() -> ProblemData {
        let num_vars = 3;
        let q = vec![1.0, 1.0, 1.0];
        let e = std::f64::consts::E;
        let triplets = vec![
            (0, 0, -1.0), (1, 1, -1.0), (2, 2, -1.0),
            (3, 1, 1.0), (4, 2, 1.0),
        ];
        let A = sparse::from_triplets(5, num_vars, triplets);
        let b = vec![0.0, 0.0, 0.0, 1.0, e];
        ProblemData {
            P: None,
            q,
            A,
            b,
            cones: vec![ConeSpec::Exp { count: 1 }, ConeSpec::Zero { dim: 2 }],
            var_bounds: None,
            integrality: None,
        }
    }

    /// Create n independent copies of the trivial exp cone problem
    pub fn trivial_multi(n: usize) -> ProblemData {
        let num_vars = n;
        let q = vec![1.0; num_vars];

        // Each exp cone has 3 rows, constraint: s_i = [-x_i, 1, 1] ∈ K_exp
        let mut triplets = Vec::new();
        for i in 0..n {
            let row_base = 3 * i;
            triplets.push((row_base, i, -1.0));
        }

        let num_rows = 3 * n;
        let A = sparse::from_triplets(num_rows, num_vars, triplets);

        let mut b = Vec::new();
        for _ in 0..n {
            b.push(0.0);  // s[3i] = 0
            b.push(1.0);  // s[3i+1] = 1
            b.push(1.0);  // s[3i+2] = 1
        }

        ProblemData {
            P: None,
            q,
            A,
            b,
            cones: vec![ConeSpec::Exp { count: n }],
            var_bounds: None,
            integrality: None,
        }
    }

    pub fn entropy_maximization(n: usize) -> ProblemData {
        let num_vars = 2 * n;
        let mut q = vec![0.0; num_vars];
        for i in 0..n {
            q[n + i] = -1.0;
        }

        let mut triplets = Vec::new();
        for i in 0..n {
            let row_offset = 3 * i;
            triplets.push((row_offset, n + i, -1.0));
            triplets.push((row_offset + 1, i, -1.0));
            triplets.push((row_offset + 2, i, -1.0));
        }
        let eq_row = 3 * n;
        for i in 0..n {
            triplets.push((eq_row, i, 1.0));
        }

        let A = sparse::from_triplets(3 * n + 1, num_vars, triplets);
        let mut b = vec![0.0; 3 * n + 1];
        b[3 * n] = 1.0;

        let mut cones = Vec::new();
        for _ in 0..n {
            cones.push(ConeSpec::Exp { count: 1 });
        }
        cones.push(ConeSpec::Zero { dim: 1 });

        ProblemData {
            P: None,
            q,
            A,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        }
    }

    pub fn kl_divergence(n: usize) -> ProblemData {
        // Use uniform target distribution
        let p: Vec<f64> = (0..n).map(|_| 1.0 / n as f64).collect();

        let num_vars = 2 * n;
        let mut q = vec![0.0; num_vars];
        for i in 0..n {
            q[i] = -p[i].ln();
            q[n + i] = 1.0;
        }

        let mut triplets = Vec::new();
        for i in 0..n {
            let row_offset = 3 * i;
            triplets.push((row_offset, n + i, -1.0));
            triplets.push((row_offset + 1, i, -1.0));
            triplets.push((row_offset + 2, i, -1.0));
        }
        let eq_row = 3 * n;
        for i in 0..n {
            triplets.push((eq_row, i, 1.0));
        }

        let A = sparse::from_triplets(3 * n + 1, num_vars, triplets);
        let mut b = vec![0.0; 3 * n + 1];
        b[3 * n] = 1.0;

        let mut cones = Vec::new();
        for _ in 0..n {
            cones.push(ConeSpec::Exp { count: 1 });
        }
        cones.push(ConeSpec::Zero { dim: 1 });

        ProblemData {
            P: None,
            q,
            A,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        }
    }

    pub fn log_sum_exp(n: usize) -> ProblemData {
        let a: Vec<f64> = (0..n).map(|i| (i as f64 + 1.0) / n as f64).collect();
        let b = 1.0_f64;

        let num_vars = n;
        let q = vec![0.0; num_vars];

        let mut triplets = Vec::new();
        for i in 0..n {
            let row_offset = 3 * i;
            triplets.push((row_offset + 2, i, -1.0));
        }
        let ineq_row = 3 * n;
        for i in 0..n {
            triplets.push((ineq_row, i, 1.0));
        }

        let A = sparse::from_triplets(3 * n + 1, num_vars, triplets);
        let mut b_vec = Vec::new();
        for i in 0..n {
            b_vec.push(a[i]);
            b_vec.push(1.0);
            b_vec.push(0.0);
        }
        b_vec.push(b.exp());

        let mut cones = Vec::new();
        for _ in 0..n {
            cones.push(ConeSpec::Exp { count: 1 });
        }
        cones.push(ConeSpec::NonNeg { dim: 1 });

        ProblemData {
            P: None,
            q,
            A,
            b: b_vec,
            cones,
            var_bounds: None,
            integrality: None,
        }
    }
}

struct BenchResult {
    name: String,
    n: usize,
    status: SolveStatus,
    iters: usize,
    time_ms: f64,
    obj: f64,
}

fn main() {
    // Use properly-sized multi-cone problems
    let problems: Vec<(&str, Box<dyn Fn() -> ProblemData>, usize)> = vec![
        ("trivial-1", Box::new(|| bench_problems::trivial()), 1),
        ("cvxpy-3", Box::new(|| bench_problems::cvxpy_style()), 3),
        ("trivial-multi-2", Box::new(|| bench_problems::trivial_multi(2)), 2),
        ("trivial-multi-5", Box::new(|| bench_problems::trivial_multi(5)), 5),
        ("trivial-multi-10", Box::new(|| bench_problems::trivial_multi(10)), 10),
    ];

    let mut settings = SolverSettings::default();
    settings.max_iter = 250;  // Allow more iterations for harder problems
    settings.verbose = false;

    println!("\n{:=<80}", "");
    println!("EXPONENTIAL CONE BENCHMARK SUITE");
    println!("{:=<80}\n", "");

    println!("{:<20} {:>6} {:>8} {:>12} {:>12} {:>10}",
             "Problem", "n", "Status", "Iters", "Time (ms)", "Objective");
    println!("{:-<80}", "");

    let mut results = Vec::new();

    for (name, prob_fn, n) in problems {
        let prob = prob_fn();

        // Warm-up
        let _ = solve(&prob, &settings);

        // Timed solve
        let start = Instant::now();
        let result = solve(&prob, &settings);
        let elapsed = start.elapsed().as_secs_f64() * 1000.0;

        let (status, iters, obj) = match result {
            Ok(sol) => (sol.status, sol.info.iters, sol.obj_val),
            Err(_) => (SolveStatus::NumericalError, 0, f64::NAN),
        };

        let status_str = match status {
            SolveStatus::Optimal => "Optimal",
            SolveStatus::AlmostOptimal => "AlmostOpt",
            SolveStatus::PrimalInfeasible => "PrInfeas",
            SolveStatus::DualInfeasible => "DuInfeas",
            SolveStatus::MaxIters => "MaxIter",
            SolveStatus::NumericalError => "NumError",
            _ => "Other",
        };

        println!("{:<20} {:>6} {:>8} {:>12} {:>12.2} {:>12.4}",
                 name, n, status_str, iters, elapsed, obj);

        results.push(BenchResult {
            name: name.to_string(),
            n,
            status,
            iters,
            time_ms: elapsed,
            obj,
        });
    }

    println!("{:-<80}", "");

    // Summary statistics
    let optimal_count = results.iter().filter(|r| r.status == SolveStatus::Optimal).count();
    let total_time: f64 = results.iter().map(|r| r.time_ms).sum();
    let avg_time = total_time / results.len() as f64;
    let avg_iters: f64 = results.iter().map(|r| r.iters as f64).sum::<f64>() / results.len() as f64;

    println!("\nSummary:");
    println!("  Solved: {}/{}", optimal_count, results.len());
    println!("  Avg time: {:.2} ms", avg_time);
    println!("  Avg iters: {:.1}", avg_iters);
    println!("  Total time: {:.2} ms\n", total_time);

    println!("{:=<80}\n", "");
}

=== examples/exp_cone_timing.rs ===
//! Exp cone wall-clock timing benchmark

use solver_core::{ConeSpec, ProblemData, SolverSettings, solve};
use solver_core::linalg::sparse;
use std::time::Instant;

fn exp_cone_trivial() -> ProblemData {
    let num_vars = 1;
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let A = sparse::from_triplets(3, num_vars, triplets);
    let b = vec![0.0, 1.0, 1.0];
    let cones = vec![ConeSpec::Exp { count: 1 }];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

fn exp_cone_cvxpy() -> ProblemData {
    let num_vars = 3;
    let q = vec![1.0, 1.0, 1.0];
    let e = std::f64::consts::E;

    let triplets = vec![
        (0, 0, -1.0),
        (1, 1, -1.0),
        (2, 2, -1.0),
        (3, 1, 1.0),
        (4, 2, 1.0),
    ];

    let A = sparse::from_triplets(5, num_vars, triplets);
    let b = vec![0.0, 0.0, 0.0, 1.0, e];

    let cones = vec![
        ConeSpec::Exp { count: 1 },
        ConeSpec::Zero { dim: 2 },
    ];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n{:=<80}", "");
    println!("EXPONENTIAL CONE WALL-CLOCK TIMING BENCHMARK");
    println!("{:=<80}\n", "");

    let problems = vec![
        ("Trivial (n=1, m=3)", exp_cone_trivial(), 50),
        ("CVXPY-style (n=3, m=5)", exp_cone_cvxpy(), 200),
    ];

    println!("{:<30} {:>10} {:>12} {:>15} {:>10}",
             "Problem", "Iters", "Time (ms)", "Objective", "µs/iter");
    println!("{:-<80}", "");

    for (name, prob, max_iter) in problems {
        let mut settings = SolverSettings::default();
        settings.verbose = false;
        settings.max_iter = max_iter;
        settings.use_proximity_step_control = false;  // Disabled

        // Warmup run
        let _ = solve(&prob, &settings);

        // Timed runs (5 iterations for average)
        let mut times = Vec::new();
        let mut iters = 0;
        let mut obj = 0.0;

        for _ in 0..5 {
            let start = Instant::now();
            let result = solve(&prob, &settings).unwrap();
            let elapsed = start.elapsed();
            times.push(elapsed.as_micros() as f64 / 1000.0);
            iters = result.info.iters;
            obj = result.obj_val;
        }

        let avg_time = times.iter().sum::<f64>() / times.len() as f64;
        let time_per_iter = (avg_time * 1000.0) / iters as f64; // microseconds

        println!("{:<30} {:>10} {:>12.2} {:>15.6} {:>10.1}",
                 name, iters, avg_time, obj, time_per_iter);
    }

    println!("{:=<80}\n", "");
}

=== examples/exp_cone_timing_proximity.rs ===
use solver_core::{sparse, ConeSpec, ProblemData, SolverSettings, solve};

fn main() {
    // Test problem 1: Trivial exp cone problem
    let num_vars = 1;
    let triplets = vec![(0, 0, 1.0), (1, 0, 0.0), (2, 0, 0.0)];
    let A = sparse::from_triplets(3, num_vars, triplets);
    let b = vec![0.0, 1.0, 1.0];
    let q = vec![1.0];
    let prob1 = ProblemData {
        P: sparse::zeros(num_vars, num_vars),
        q,
        A,
        b,
        cones: vec![ConeSpec::ExponentialCone { count: 1 }],
    };

    // Test problem 2: CVXPY-style exp cone problem
    let num_vars = 3;
    let triplets = vec![
        (0, 0, 1.0), (1, 0, 0.0), (2, 0, 0.0),
        (0, 1, 0.0), (1, 1, 1.0), (2, 1, 0.0),
        (3, 2, 1.0), (4, 2, 1.0),
    ];
    let A = sparse::from_triplets(5, num_vars, triplets);
    let b = vec![0.0, 0.5, 1.0, 1.0, 2.0];
    let q = vec![-1.0, 0.0, 0.0];
    let prob2 = ProblemData {
        P: sparse::zeros(num_vars, num_vars),
        q,
        A,
        b,
        cones: vec![ConeSpec::ExponentialCone { count: 1 }, ConeSpec::Zero { dim: 2 }],
    };

    println!("================================================================================");
    println!("EXPONENTIAL CONE TIMING WITH PROXIMITY STEP CONTROL");
    println!("================================================================================");
    println!();
    println!("{:35} {:>5}    {:>8}       {:>10}    {:>7}", "Problem", "Iters", "Time (ms)", "Objective", "µs/iter");
    println!("--------------------------------------------------------------------------------");

    // Enable proximity step control
    let mut settings = SolverSettings::default();
    settings.max_iter = 200;
    settings.use_proximity_step_control = true;

    // Benchmark trivial problem
    let start = std::time::Instant::now();
    let result1 = solve(&prob1, &settings).unwrap();
    let time1 = start.elapsed().as_secs_f64() * 1000.0;
    let us_per_iter1 = (time1 * 1000.0) / (result1.info.iters as f64);

    println!("{:35} {:>5}    {:>8.2}    {:>12.6}    {:>7.1}",
             "Trivial (n=1, m=3)",
             result1.info.iters,
             time1,
             result1.info.obj_val,
             us_per_iter1);

    // Benchmark CVXPY-style problem
    let start = std::time::Instant::now();
    let result2 = solve(&prob2, &settings).unwrap();
    let time2 = start.elapsed().as_secs_f64() * 1000.0;
    let us_per_iter2 = (time2 * 1000.0) / (result2.info.iters as f64);

    println!("{:35} {:>5}    {:>8.2}    {:>12.6}    {:>7.1}",
             "CVXPY-style (n=3, m=5)",
             result2.info.iters,
             time2,
             result2.info.obj_val,
             us_per_iter2);

    println!("================================================================================");
}

=== examples/exp_cone_trace.rs ===
//! Trace exp cone solver iterations to see where it gets stuck

use solver_core::{ConeSpec, ProblemData, SolverSettings, solve};
use solver_core::linalg::sparse;

fn trivial() -> ProblemData {
    // min x
    // s.t. s = [-x, 1, 1] ∈ K_exp
    //
    // Optimal: x = 0 (since s = [0, 1, 1] satisfies 1*exp(0/1) = 1 ≤ 1)
    let num_vars = 1;
    let q = vec![1.0];
    let triplets = vec![(0, 0, -1.0)];
    let a = sparse::from_triplets(3, num_vars, triplets);
    let b = vec![0.0, 1.0, 1.0];
    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![ConeSpec::Exp { count: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn main() {
    println!("\n=== Exp Cone Trivial Problem ===");
    println!("min x s.t. s = [-x, 1, 1] ∈ K_exp");
    println!("Expected: x = 0, obj = 0");
    println!();

    let prob = trivial();
    let settings = SolverSettings {
        verbose: true,  // Enable verbose to see iteration progress
        max_iter: 20,   // Just 20 iterations to see initial behavior
        tol_feas: 1e-8,
        tol_gap: 1e-8,
        ..Default::default()
    };

    match solve(&prob, &settings) {
        Ok(sol) => {
            println!("\n=== Solution ===");
            println!("Status: {:?}", sol.status);
            println!("Iterations: {}", sol.info.iters);
            println!("x = {:?}", sol.x);
            println!("s = {:?}", sol.s);
            println!("z = {:?}", sol.z);
            println!("Objective: {:.6e}", sol.obj_val);
            println!("\nResiduals:");
            println!("  primal_res: {:.6e}", sol.info.primal_res);
            println!("  dual_res:   {:.6e}", sol.info.dual_res);
            println!("  gap:        {:.6e}", sol.info.gap);
            println!("  mu:         {:.6e}", sol.info.mu);
        },
        Err(e) => println!("Error: {:?}", e),
    }
}

=== examples/measure_cone_iterations.rs ===
// Standalone example - copy test_problems logic here since examples can't import from bin crates

use solver_core::SolverSettings;

#[path = "../src/test_problems.rs"]
mod test_problems;

fn main() {
    let mut settings = SolverSettings::default();
    settings.max_iter = 200;

    println!("Measuring exact iteration counts for cone problems (max_iter=200)...\n");

    for prob in test_problems::synthetic_test_problems() {
        let problem_data = (prob.builder)();
        match solver_core::solve(&problem_data, &settings) {
            Ok(res) => {
                println!("\"{}\" => Some({}),  // {:?}",
                    prob.name, res.info.iters, res.status);
            }
            Err(e) => {
                println!("\"{}\" => None,  // ERROR: {}", prob.name, e);
            }
        }
    }
}

=== src/comparison.rs ===
//! Multi-solver comparison and win matrix generation.

use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufReader, BufWriter};
use std::path::Path;

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use solver_core::SolveStatus;

use crate::maros_meszaros::{BenchmarkResult, BenchmarkSummary};

/// Results from a single solver run
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SolverResults {
    /// Solver name
    pub solver_name: String,
    /// Results for each problem
    pub results: Vec<BenchmarkResult>,
    /// Summary statistics
    pub summary: BenchmarkSummary,
}

impl SolverResults {
    /// Create from a list of benchmark results
    pub fn new(solver_name: String, results: Vec<BenchmarkResult>) -> Self {
        let summary = crate::maros_meszaros::compute_summary(&results);
        Self {
            solver_name,
            results,
            summary,
        }
    }

    /// Save to JSON file
    pub fn save_json<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let file = File::create(path.as_ref())
            .with_context(|| format!("Failed to create file {}", path.as_ref().display()))?;
        let writer = BufWriter::new(file);
        serde_json::to_writer_pretty(writer, self)
            .with_context(|| format!("Failed to write JSON to {}", path.as_ref().display()))?;
        Ok(())
    }

    /// Load from JSON file
    pub fn load_json<P: AsRef<Path>>(path: P) -> Result<Self> {
        let file = File::open(path.as_ref())
            .with_context(|| format!("Failed to open file {}", path.as_ref().display()))?;
        let reader = BufReader::new(file);
        serde_json::from_reader(reader)
            .with_context(|| format!("Failed to parse JSON from {}", path.as_ref().display()))
    }
}

/// Comparison between multiple solvers
pub struct SolverComparison {
    /// Results from each solver
    pub solvers: Vec<SolverResults>,
}

impl SolverComparison {
    /// Create a new comparison
    pub fn new(solvers: Vec<SolverResults>) -> Self {
        Self { solvers }
    }

    /// Get all problem names that appear in any solver results
    fn all_problems(&self) -> HashSet<String> {
        let mut problems = HashSet::new();
        for solver in &self.solvers {
            for result in &solver.results {
                problems.insert(result.name.clone());
            }
        }
        problems
    }

    /// Build a map from problem name to result for a solver
    fn problem_map(results: &[BenchmarkResult]) -> HashMap<String, &BenchmarkResult> {
        results.iter().map(|r| (r.name.clone(), r)).collect()
    }

    /// Check if a result is considered "solved" (Optimal or AlmostOptimal)
    fn is_solved(status: SolveStatus) -> bool {
        matches!(status, SolveStatus::Optimal | SolveStatus::AlmostOptimal)
    }

    /// Print summary table comparing all solvers
    pub fn print_summary(&self) {
        println!("\n{}", "=".repeat(80));
        println!("Multi-Solver Comparison Summary");
        println!("{}", "=".repeat(80));

        println!(
            "\n{:<20} {:>10} {:>10} {:>10} {:>15} {:>15}",
            "Solver", "Optimal", "AlmostOpt", "Combined", "Geom Mean Time", "Pass Rate"
        );
        println!("{}", "-".repeat(80));

        for solver in &self.solvers {
            let combined = solver.summary.optimal + solver.summary.almost_optimal;
            let pass_rate = 100.0 * combined as f64 / solver.summary.total as f64;

            println!(
                "{:<20} {:>10} {:>10} {:>10} {:>15.2}ms {:>14.1}%",
                solver.solver_name,
                solver.summary.optimal,
                solver.summary.almost_optimal,
                combined,
                solver.summary.geom_mean_time_ms,
                pass_rate
            );
        }

        println!("{}", "=".repeat(80));
    }

    /// Print win matrix showing head-to-head problem solving
    pub fn print_win_matrix(&self) {
        println!("\n{}", "=".repeat(80));
        println!("Win Matrix: Problems Solved by Each Solver Pair");
        println!("{}", "=".repeat(80));
        println!("Format: A vs B shows (problems A solves that B doesn't | both solve | B solves that A doesn't)");
        println!("{}", "-".repeat(80));

        let n = self.solvers.len();

        // Print header
        print!("\n{:<20}", "");
        for solver in &self.solvers {
            print!(" {:>20}", &solver.solver_name[..solver.solver_name.len().min(20)]);
        }
        println!();
        println!("{}", "-".repeat(20 + n * 21));

        // For each row solver
        for (i, solver_a) in self.solvers.iter().enumerate() {
            print!("{:<20}", &solver_a.solver_name[..solver_a.solver_name.len().min(20)]);

            let map_a = Self::problem_map(&solver_a.results);

            // For each column solver
            for (j, solver_b) in self.solvers.iter().enumerate() {
                if i == j {
                    // Diagonal: show total solved
                    let solved = solver_a.summary.optimal + solver_a.summary.almost_optimal;
                    print!(" {:>20}", format!("({} solved)", solved));
                } else {
                    let map_b = Self::problem_map(&solver_b.results);

                    let mut a_only = 0;
                    let mut both = 0;
                    let mut b_only = 0;

                    for problem in self.all_problems() {
                        let a_solved = map_a
                            .get(&problem)
                            .map(|r| Self::is_solved(r.status))
                            .unwrap_or(false);
                        let b_solved = map_b
                            .get(&problem)
                            .map(|r| Self::is_solved(r.status))
                            .unwrap_or(false);

                        match (a_solved, b_solved) {
                            (true, false) => a_only += 1,
                            (true, true) => both += 1,
                            (false, true) => b_only += 1,
                            (false, false) => {}
                        }
                    }

                    print!(" {:>20}", format!("{}|{}|{}", a_only, both, b_only));
                }
            }
            println!();
        }

        println!("{}", "=".repeat(80));
    }

    /// Print performance comparison on commonly solved problems
    pub fn print_performance_comparison(&self) {
        println!("\n{}", "=".repeat(80));
        println!("Performance Comparison (Geometric Mean Time on Commonly Solved Problems)");
        println!("{}", "=".repeat(80));

        let n = self.solvers.len();

        // For each pair of solvers
        for i in 0..n {
            for j in (i + 1)..n {
                let solver_a = &self.solvers[i];
                let solver_b = &self.solvers[j];

                let map_a = Self::problem_map(&solver_a.results);
                let map_b = Self::problem_map(&solver_b.results);

                // Find commonly solved problems
                let mut common_times_a = Vec::new();
                let mut common_times_b = Vec::new();

                for problem in self.all_problems() {
                    if let (Some(res_a), Some(res_b)) = (map_a.get(&problem), map_b.get(&problem)) {
                        if Self::is_solved(res_a.status) && Self::is_solved(res_b.status) {
                            common_times_a.push(res_a.solve_time_ms);
                            common_times_b.push(res_b.solve_time_ms);
                        }
                    }
                }

                if common_times_a.is_empty() {
                    println!(
                        "\n{} vs {}: No commonly solved problems",
                        solver_a.solver_name, solver_b.solver_name
                    );
                    continue;
                }

                // Compute shifted geometric mean
                let geom_mean_a = Self::geom_mean(&common_times_a);
                let geom_mean_b = Self::geom_mean(&common_times_b);

                println!(
                    "\n{} vs {} ({} common problems):",
                    solver_a.solver_name, solver_b.solver_name, common_times_a.len()
                );
                println!("  {:<20} {:.2}ms", solver_a.solver_name, geom_mean_a);
                println!("  {:<20} {:.2}ms", solver_b.solver_name, geom_mean_b);

                if geom_mean_a < geom_mean_b {
                    println!("  {} is {:.2}x faster", solver_a.solver_name, geom_mean_b / geom_mean_a);
                } else if geom_mean_b < geom_mean_a {
                    println!("  {} is {:.2}x faster", solver_b.solver_name, geom_mean_a / geom_mean_b);
                } else {
                    println!("  Same performance");
                }
            }
        }

        println!("{}", "=".repeat(80));
    }

    /// Compute shifted geometric mean
    fn geom_mean(times: &[f64]) -> f64 {
        if times.is_empty() {
            return 0.0;
        }

        let log_sum: f64 = times.iter().map(|&t| (t + 1.0).ln()).sum();
        (log_sum / times.len() as f64).exp() - 1.0
    }

    /// Print detailed problem-by-problem comparison
    pub fn print_detailed_comparison(&self, limit: Option<usize>) {
        println!("\n{}", "=".repeat(100));
        println!("Detailed Problem-by-Problem Comparison");
        println!("{}", "=".repeat(100));

        let problems: Vec<String> = self.all_problems().into_iter().collect();
        let mut problems = problems;
        problems.sort();

        // Build maps for each solver
        let solver_maps: Vec<HashMap<String, &BenchmarkResult>> =
            self.solvers.iter().map(|s| Self::problem_map(&s.results)).collect();

        // Print header
        print!("\n{:<15}", "Problem");
        for solver in &self.solvers {
            print!(" {:>15}", &solver.solver_name[..solver.solver_name.len().min(15)]);
        }
        println!();

        print!("{:<15}", "");
        for _ in &self.solvers {
            print!(" {:>7} {:>7}", "Status", "Time(ms)");
        }
        println!();
        println!("{}", "-".repeat(15 + self.solvers.len() * 16));

        let show_limit = limit.unwrap_or(problems.len());
        for problem in problems.iter().take(show_limit) {
            print!("{:<15}", problem);

            for map in &solver_maps {
                if let Some(result) = map.get(problem) {
                    let status_str = match result.status {
                        SolveStatus::Optimal => "Opt",
                        SolveStatus::AlmostOptimal => "AlmOpt",
                        SolveStatus::MaxIters => "MaxIt",
                        SolveStatus::NumericalError => "NumErr",
                        _ => "Other",
                    };
                    print!(" {:>7} {:>7.1}", status_str, result.solve_time_ms);
                } else {
                    print!(" {:>7} {:>7}", "-", "-");
                }
            }
            println!();
        }

        if problems.len() > show_limit {
            println!("... and {} more problems", problems.len() - show_limit);
        }

        println!("{}", "=".repeat(100));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use solver_core::SolveStatus;

    fn make_test_result(name: &str, status: SolveStatus, time_ms: f64) -> BenchmarkResult {
        BenchmarkResult {
            name: name.to_string(),
            n: 10,
            m: 5,
            status,
            iterations: 10,
            obj_val: 1.0,
            mu: 1e-8,
            solve_time_ms: time_ms,
            error: None,
        }
    }

    #[test]
    fn test_win_matrix() {
        let solver_a = SolverResults::new(
            "SolverA".to_string(),
            vec![
                make_test_result("P1", SolveStatus::Optimal, 1.0),
                make_test_result("P2", SolveStatus::Optimal, 2.0),
                make_test_result("P3", SolveStatus::MaxIters, 3.0),
            ],
        );

        let solver_b = SolverResults::new(
            "SolverB".to_string(),
            vec![
                make_test_result("P1", SolveStatus::Optimal, 1.5),
                make_test_result("P2", SolveStatus::MaxIters, 2.5),
                make_test_result("P3", SolveStatus::Optimal, 3.5),
            ],
        );

        let comparison = SolverComparison::new(vec![solver_a, solver_b]);

        // Just test that it doesn't panic
        comparison.print_win_matrix();
        comparison.print_performance_comparison();
    }
}

=== src/conic_benchmarks.rs ===
/// Benchmark problems for exponential and SDP cones
use solver_core::{ProblemData, ConeSpec, SolverSettings, solve, SolveStatus};
use solver_core::linalg::sparse;

/// Relative entropy minimization problem using exponential cone
///
/// minimize    sum_i u_i * log(u_i / v_i)
/// subject to  sum_i u_i = 1
///             u >= 0
///
/// where v is given distribution.
///
/// Reformulation using exponential cone:
/// minimize    sum_i t_i
/// subject to  t_i >= u_i * log(u_i / v_i)   (via Exp cone)
///             sum_i u_i = 1
///             u >= 0
///
/// Exponential cone form: t >= u * log(u/v)
///   ⟺  v * exp(log(u/v)) <= v * exp(t/u)
///   ⟺  u * exp(log(u/v)) <= u * exp(t/u)  (multiply by u/v)
///   ⟺  exp((log(u) - log(v))) <= exp(t/u)
///   ⟺  log(u) - log(v) <= t/u
///   ⟺  u*log(u/v) <= t
///
/// Standard exponential cone: {(x,y,z) : y*exp(x/y) <= z, y > 0}
/// Our constraint: u*exp(log(u/v)) <= v*exp(t/u)
///
/// Let me use the proper formulation:
/// (log(u/v), u, t) ∈ K_exp
/// which means: u * exp(log(u/v) / u) <= t
///             u * exp(log(u/v) / u) <= t
///             u * (u/v)^(1/u) <= t
///
/// Actually, cleaner formulation:
/// (-t, u, u*v) ∈ K_exp means: u * exp(-t/u) <= u*v
///   ⟺  exp(-t/u) <= v
///   ⟺  -t/u <= log(v)
///   ⟺  t >= -u*log(v) = u*log(1/v)
///
/// No wait, let's use the standard relative entropy form:
/// t >= u*log(u) - u*log(v)
///   = u*log(u) - u*log(v)
///
/// Split into two parts:
/// 1. t1 >= u*log(u)   via (-t1, u, u) ∈ K_exp
/// 2. t2 = -u*log(v)   = u*log(v) where we know v
///
/// For (-t, u, u) ∈ K_exp: u*exp(-t/u) <= u  ⟺  exp(-t/u) <= 1  ⟺  -t/u <= 0  ⟺  t >= 0
///
/// Hmm, that's not right either. Let me use the CVXPY formulation.
///
/// Standard: minimize sum(entr(u)) where entr(x) = -x*log(x)
/// Using Exp cone: -x*log(x) is captured by (x, 1, z) ∈ K_exp with x*exp(x/x) <= z
///
/// Actually, CVXPY uses: entr(x) represented via (-x, 1, z) ∈ K_exp
/// which gives: 1*exp(-x/1) <= z  ⟺  exp(-x) <= z
///
/// For relative entropy: sum_i u_i*log(u_i/v_i) = sum_i (u_i*log(u_i) - u_i*log(v_i))
///
/// Let me just implement a simple exponential cone problem first.
/// Simple exponential cone test adapted from CVXPY
///
/// minimize    x + y + z
/// subject to  y*exp(x/y) <= z
///             y == 1, z == exp(1)
///
/// This forces x = 1 at optimum, giving objective = 1 + 1 + e ≈ 4.718
pub fn exp_cone_cvxpy_style() -> ProblemData {
    // Variables: [x, y, z]
    // Standard form: minimize c'v s.t. Av + s = b, s ∈ K
    let num_vars = 3;

    // Objective: min x + y + z
    let q = vec![1.0, 1.0, 1.0];

    // Constraints:
    // Row 0-2: Exponential cone (x, y, z) with s[0:3] = (x, y, z) must be in K_exp
    // Row 3: y + s[3] = 1  (equality: y = 1)
    // Row 4: z + s[4] = e  (equality: z = e)
    let e = std::f64::consts::E;

    let triplets = vec![
        // Exp cone rows: -I * [x,y,z]' + s[0:3] = 0
        (0, 0, -1.0),  // -x + s[0] = 0  ⟹  s[0] = x
        (1, 1, -1.0),  // -y + s[1] = 0  ⟹  s[1] = y
        (2, 2, -1.0),  // -z + s[2] = 0  ⟹  s[2] = z
        // Equality constraints (Zero cone)
        (3, 1, 1.0),   // y + s[3] = 1   ⟹  s[3] = 1 - y (must be 0)
        (4, 2, 1.0),   // z + s[4] = e   ⟹  s[4] = e - z (must be 0)
    ];

    let A = sparse::from_triplets(5, num_vars, triplets);
    let b = vec![0.0, 0.0, 0.0, 1.0, e];

    let cones = vec![
        ConeSpec::Exp { count: 1 },   // Rows 0-2
        ConeSpec::Zero { dim: 2 },    // Rows 3-4
    ];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

pub fn relative_entropy_simple(_n: usize) -> ProblemData {
    // Simple unbounded exponential cone problem for debugging
    // minimize    x + y
    // subject to  (x, 1, y) ∈ K_exp  i.e., y >= exp(x)
    //
    // Without upper bounds, we want x → -∞ and y → 0, making this unbounded.
    // Let's add: y >= 1
    //
    // Then optimal is: y = exp(x), minimize x + exp(x)
    // d/dx[x + exp(x)] = 1 + exp(x) > 0 always, so minimize by x → -∞
    // But y >= 1 means exp(x) >= 1, so x >= 0
    // At x=0: objective = 0 + 1 = 1

    let num_vars = 2; // [x, y]

    // Objective: min x + y
    let q = vec![1.0, 1.0];

    // Constraints:
    // Row 0-2: Exponential cone (x, 1, y) where s = (x, 1, y)
    // Row 3: y + s[3] = 1  (y >= 1 via slack)
    let triplets = vec![
        (0, 0, -1.0),  // -x + s[0] = 0   ⟹  s[0] = x
        // Row 1: s[1] = 1 (no variable terms)
        (2, 1, -1.0),  // -y + s[2] = 0   ⟹  s[2] = y
        (3, 1, 1.0),   // y + s[3] = 1    ⟹  s[3] = 1 - y
    ];

    let A = sparse::from_triplets(4, num_vars, triplets);
    let b = vec![0.0, 1.0, 0.0, 1.0];

    let cones = vec![
        ConeSpec::Exp { count: 1 },   // Rows 0-2
        ConeSpec::NonNeg { dim: 1 },  // Row 3
    ];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

/// Simple SDP problem: minimize trace(C*X) subject to trace(A_i*X) = b_i, X ⪰ 0
///
/// Example: Find minimum trace PSD matrix with fixed diagonal
/// minimize    trace(X)
/// subject to  X_ii = 1 for all i
///             X ⪰ 0
///
/// This has solution X = I (identity matrix)
pub fn sdp_trace_minimization(n: usize) -> ProblemData {
    // Variables: X is n×n symmetric matrix
    // In svec format: dim = n*(n+1)/2

    let sdp_dim = n * (n + 1) / 2;

    // Objective: minimize trace(X)
    // trace(X) = sum_i X_ii
    // In svec format (upper-triangular column-major):
    // Element (i,j) with i<=j is at index j*(j+1)/2 + i
    // So diagonal X_kk is at index k*(k+1)/2 + k = k*(k+3)/2
    let mut q = vec![0.0; sdp_dim];
    for k in 0..n {
        let diag_idx = k * (k + 3) / 2;
        q[diag_idx] = 1.0;
    }

    // Constraints are partitioned into two blocks:
    // 1. Zero cone (n rows): X_ii = 1
    // 2. PSD cone (sdp_dim rows): X itself in svec format must be PSD
    //
    // Total rows: n + sdp_dim

    let mut triplets = Vec::new();

    // Block 1: Zero cone constraints (rows 0..n)
    // X_kk + s_zero[k] = 1, where s_zero[k] must be 0
    for k in 0..n {
        let diag_idx = k * (k + 3) / 2;
        triplets.push((k, diag_idx, 1.0));
    }

    // Block 2: PSD cone constraints (rows n..n+sdp_dim)
    // -x + s_psd = 0, where s_psd = x must be in PSD cone
    // This is: -I * x + s_psd = 0
    for i in 0..sdp_dim {
        triplets.push((n + i, i, -1.0));
    }

    let A = sparse::from_triplets(n + sdp_dim, sdp_dim, triplets);
    let mut b = vec![1.0; n];  // X_ii = 1
    b.extend(vec![0.0; sdp_dim]);  // PSD constraint

    let cones = vec![
        ConeSpec::Zero { dim: n },
        ConeSpec::Psd { n },
    ];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

/// Maximum cut SDP relaxation
///
/// Given graph with adjacency matrix W, find maximum cut.
/// SDP relaxation:
/// maximize    (1/4) * sum_{i,j} W_ij * (1 - X_ij)
/// subject to  X_ii = 1 for all i
///             X ⪰ 0
///
/// Equivalently (in minimization form):
/// minimize    -(1/4) * sum_{i,j} W_ij + (1/4) * sum_{i,j} W_ij * X_ij
/// subject to  X_ii = 1 for all i
///             X ⪰ 0
pub fn sdp_maxcut(n: usize, edges: &[(usize, usize, f64)]) -> ProblemData {
    let sdp_dim = n * (n + 1) / 2;

    // Build objective from edge weights
    let mut q = vec![0.0; sdp_dim];

    // Helper: get svec index for (i,j) with i <= j
    // Upper-triangular column-major: index = j*(j+1)/2 + i
    let svec_idx = |i: usize, j: usize| -> usize {
        assert!(i <= j);
        j * (j + 1) / 2 + i
    };

    for &(i, j, w) in edges {
        let (ii, jj) = if i < j { (i, j) } else { (j, i) };
        let idx = svec_idx(ii, jj);
        q[idx] += 0.25 * w * if ii == jj { 1.0 } else { std::f64::consts::SQRT_2 };
    }

    // Constraints partitioned into two blocks:
    // 1. Zero cone: X_ii = 1
    // 2. PSD cone: X ⪰ 0
    let mut triplets = Vec::new();

    // Block 1: Zero cone (rows 0..n)
    for i in 0..n {
        triplets.push((i, svec_idx(i, i), 1.0));
    }

    // Block 2: PSD cone (rows n..n+sdp_dim)
    for i in 0..sdp_dim {
        triplets.push((n + i, i, -1.0));
    }

    let A = sparse::from_triplets(n + sdp_dim, sdp_dim, triplets);
    let mut b = vec![1.0; n];
    b.extend(vec![0.0; sdp_dim]);

    let cones = vec![
        ConeSpec::Zero { dim: n },
        ConeSpec::Psd { n },
    ];

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exp_debug_trivial() {
        // Simplest possible exp cone problem
        // minimize x
        // subject to (x, 1, 1) ∈ K_exp  i.e., exp(x) ≤ 1, so x ≤ 0
        // Optimal: x = 0, objective = 0

        let num_vars = 1;
        let q = vec![1.0];
        let triplets = vec![(0, 0, -1.0)];
        let A = sparse::from_triplets(3, num_vars, triplets);
        let b = vec![0.0, 1.0, 1.0];
        let cones = vec![ConeSpec::Exp { count: 1 }];

        let prob = ProblemData {
            P: None,
            q,
            A,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        };

        let mut settings = SolverSettings::default();
        settings.max_iter = 20;
        settings.verbose = true;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Exp Cone Trivial Debug Test ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("Solution: x={:.6}", result.x[0]);
        println!("\nExpected: x=0, objective=0");
    }

    #[test]
    fn test_exponential_cone_cvxpy() {
        let prob = exp_cone_cvxpy_style();
        let mut settings = SolverSettings::default();
        settings.max_iter = 200;
        settings.verbose = false;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Exponential Cone (CVXPY style) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("Solution: x={:.6}, y={:.6}, z={:.6}", result.x[0], result.x[1], result.x[2]);

        // Expected: x=1, y=1, z=e, objective = 1 + 1 + e ≈ 4.718
        if matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal) {
            let expected_obj = 1.0 + 1.0 + std::f64::consts::E;
            assert!((result.obj_val - expected_obj).abs() < 0.1,
                "Objective should be ~{}, got {}", expected_obj, result.obj_val);
        }
    }

    #[test]
    fn test_exponential_cone_simple() {
        let prob = relative_entropy_simple(5);
        let mut settings = SolverSettings::default();
        settings.max_iter = 200;
        settings.verbose = false;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Exponential Cone (simple) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("Solution: x={:.6}, y={:.6}", result.x[0], result.x[1]);

        // Expected: x=0, y=1, objective = 0 + 1 = 1
        if matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal) {
            assert!((result.obj_val - 1.0).abs() < 0.1,
                "Objective should be ~1.0, got {}", result.obj_val);
        }
    }

    #[test]
    fn test_sdp_simple_psd_only() {
        // Simple PSD-only test: minimize trace(X) subject to X ⪰ 0
        // No Zero cone constraints. Optimal is X = 0 (trace = 0).
        let n = 2;  // Start with 2x2 to debug
        let sdp_dim = n * (n + 1) / 2;  // 3 for 2x2

        // Objective: minimize trace(X) = X_00 + X_11 + X_22
        let mut q = vec![0.0; sdp_dim];
        for k in 0..n {
            let diag_idx = k * (k + 3) / 2;
            q[diag_idx] = 1.0;
        }

        // Single constraint: s_psd = x (just PSD cone)
        let mut triplets = Vec::new();
        for i in 0..sdp_dim {
            triplets.push((i, i, -1.0));
        }

        let a = sparse::from_triplets(sdp_dim, sdp_dim, triplets);
        let b = vec![0.0; sdp_dim];

        let prob = ProblemData {
            P: None,
            q,
            A: a,
            b,
            cones: vec![ConeSpec::Psd { n }],
            var_bounds: None,
            integrality: None,
        };

        let mut settings = SolverSettings::default();
        settings.max_iter = 50;
        settings.verbose = true;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Simple PSD Test (minimize trace, X >= 0) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        // Optimal is X = 0, trace = 0
        assert!(result.obj_val >= -0.1, "Objective should be >= 0, got {}", result.obj_val);
    }

    #[test]
    fn test_sdp_trace_minimization() {
        let n = 3;
        let prob = sdp_trace_minimization(n);
        let mut settings = SolverSettings::default();
        settings.max_iter = 50;
        settings.verbose = true;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== SDP Trace Minimization ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        // Objective should be trace(I) = n even if not fully converged
        assert!((result.obj_val - n as f64).abs() < 0.5,
            "Objective should be ~{}, got {}", n, result.obj_val);
    }

    #[test]
    fn test_sdp_maxcut_triangle() {
        // Triangle graph: 3 nodes, all edges weight 1
        let edges = vec![(0, 1, 1.0), (1, 2, 1.0), (0, 2, 1.0)];
        let prob = sdp_maxcut(3, &edges);
        let mut settings = SolverSettings::default();
        settings.max_iter = 200;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== MaxCut SDP ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        // Should get some reasonable approximation
        // For triangle with unit weights, SDP bound is around 1.25 * optimal_cut
    }

    #[test]
    fn test_sdp_trace_minimization_4x4() {
        let n = 4;
        let prob = sdp_trace_minimization(n);
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== SDP Trace Minimization (4x4) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert_eq!(result.status, SolveStatus::Optimal);
        assert!((result.obj_val - n as f64).abs() < 0.1,
            "Objective should be ~{}, got {}", n, result.obj_val);
    }

    #[test]
    fn test_sdp_trace_minimization_5x5() {
        let n = 5;
        let prob = sdp_trace_minimization(n);
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== SDP Trace Minimization (5x5) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert_eq!(result.status, SolveStatus::Optimal);
        assert!((result.obj_val - n as f64).abs() < 0.1,
            "Objective should be ~{}, got {}", n, result.obj_val);
    }

    #[test]
    fn test_sdp_maxcut_path() {
        // Path graph: 0 - 1 - 2 - 3 (4 nodes, 3 edges)
        // Optimal cut: separate into {0,2} and {1,3}, value = 3
        let edges = vec![(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)];
        let prob = sdp_maxcut(4, &edges);
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== MaxCut SDP (Path Graph) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert!(matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal),
            "Status should be Optimal or AlmostOptimal, got {:?}", result.status);
        // SDP bound for path graph with 3 edges is -0.75 (minimization form)
        assert!(result.obj_val < 0.0, "Objective should be negative for maxcut");
    }

    #[test]
    fn test_sdp_maxcut_complete_4() {
        // Complete graph K4: 4 nodes, 6 edges (all pairs connected)
        // Optimal cut: separate into 2 groups of 2, value = 4
        let mut edges = Vec::new();
        for i in 0..4 {
            for j in (i+1)..4 {
                edges.push((i, j, 1.0));
            }
        }
        let prob = sdp_maxcut(4, &edges);
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== MaxCut SDP (K4 Complete) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert_eq!(result.status, SolveStatus::Optimal);
    }

    #[test]
    fn test_sdp_maxcut_star() {
        // Star graph: center node 0 connected to 1, 2, 3, 4
        // Optimal cut: separate center from rest, value = 4
        let edges = vec![(0, 1, 1.0), (0, 2, 1.0), (0, 3, 1.0), (0, 4, 1.0)];
        let prob = sdp_maxcut(5, &edges);
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== MaxCut SDP (Star Graph) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert_eq!(result.status, SolveStatus::Optimal);
    }

    #[test]
    fn test_sdp_lovasz_theta() {
        // Lovász theta function for pentagon (C5)
        // theta(C5) = sqrt(5) ≈ 2.236
        //
        // maximize t
        // subject to: t * I - X + sum_ij A_ij * Y_ij = 0  (equality)
        //             X_ii = 1
        //             X >= 0 (PSD)
        //
        // Simplified: maximize trace(J * X) subject to X_ii = 1, X_ij = 0 for edges, X >= 0
        // where J is all-ones matrix
        let n = 5;  // Pentagon
        let edges = vec![(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)];  // Cycle C5

        let sdp_dim = n * (n + 1) / 2;

        // Objective: maximize sum of X_ij = trace(J * X)
        // In minimization form: minimize -sum of X_ij
        let mut q = vec![0.0; sdp_dim];

        // svec index helper
        let svec_idx = |i: usize, j: usize| -> usize {
            let (i, j) = if i <= j { (i, j) } else { (j, i) };
            j * (j + 1) / 2 + i
        };

        // All entries contribute (but off-diagonals have sqrt(2) factor in svec)
        for i in 0..n {
            for j in i..n {
                let idx = svec_idx(i, j);
                if i == j {
                    q[idx] = -1.0;  // Diagonal
                } else {
                    q[idx] = -std::f64::consts::SQRT_2;  // Off-diagonal (appears twice, but svec scales)
                }
            }
        }

        // Constraints:
        // 1. X_ii = 1 for all i (n constraints)
        // 2. X_ij = 0 for all edges (5 constraints for pentagon)
        // 3. X >= 0 (PSD cone)

        let n_eq = n + edges.len();  // Diagonal + edge constraints
        let mut triplets = Vec::new();

        // Diagonal constraints: X_ii = 1
        for i in 0..n {
            let diag_idx = svec_idx(i, i);
            triplets.push((i, diag_idx, 1.0));
        }

        // Edge constraints: X_ij = 0 for (i,j) in edges
        for (k, &(i, j)) in edges.iter().enumerate() {
            let idx = svec_idx(i, j);
            triplets.push((n + k, idx, 1.0));
        }

        // PSD cone constraint: -x + s_psd = 0
        for i in 0..sdp_dim {
            triplets.push((n_eq + i, i, -1.0));
        }

        let a = sparse::from_triplets(n_eq + sdp_dim, sdp_dim, triplets);
        let mut b = vec![1.0; n];  // X_ii = 1
        b.extend(vec![0.0; edges.len()]);  // X_ij = 0 for edges
        b.extend(vec![0.0; sdp_dim]);  // PSD constraint

        let cones = vec![
            ConeSpec::Zero { dim: n_eq },  // Equality constraints
            ConeSpec::Psd { n },           // PSD cone
        ];

        let prob = ProblemData {
            P: None,
            q,
            A: a,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        };

        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Lovász Theta (Pentagon C5) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);

        assert_eq!(result.status, SolveStatus::Optimal);
        // theta(C5) = sqrt(5) ≈ 2.236
        // Our objective is -trace(J*X), so should be around -5 * sqrt(5) / 5 = -sqrt(5)
        // Actually trace(J*X) = sum_ij X_ij, and X optimal has theta(G) = sqrt(5)
    }

    #[test]
    fn test_sdp_min_eigenvalue() {
        // Find minimum eigenvalue of a matrix via SDP
        // Given symmetric C, find:
        //   maximize t
        //   subject to C - t*I >= 0 (PSD)
        //
        // Standard form (minimize):
        //   minimize -t
        //   subject to s = C - t*I, s in PSD cone
        //
        // Rewritten with slack:
        //   Variables: t, s (svec form)
        //   Minimize: -t
        //   Subject to: t*I + s = C  (Zero cone for equality)
        //               s in PSD cone

        let n = 3;
        let sdp_dim = n * (n + 1) / 2;  // 6 for 3x3

        // Test matrix C (symmetric, with known eigenvalues)
        // C = [3, 1, 0; 1, 2, 1; 0, 1, 1]
        // Eigenvalues approximately: 3.73, 1.62, 0.65
        let c_mat = vec![
            3.0, 1.0, 0.0,
            1.0, 2.0, 1.0,
            0.0, 1.0, 1.0,
        ];

        // Convert C to svec format
        let mut c_svec = vec![0.0; sdp_dim];
        let svec_idx = |i: usize, j: usize| -> usize {
            let (i, j) = if i <= j { (i, j) } else { (j, i) };
            j * (j + 1) / 2 + i
        };

        for i in 0..n {
            for j in i..n {
                let idx = svec_idx(i, j);
                let val = c_mat[i * n + j];
                c_svec[idx] = if i == j { val } else { val * std::f64::consts::SQRT_2 };
            }
        }

        // Variables: x = [t, s_0, s_1, ..., s_{sdp_dim-1}]
        // Objective: minimize -t => q = [-1, 0, 0, ..., 0]
        let num_vars = 1 + sdp_dim;
        let mut q = vec![0.0; num_vars];
        q[0] = -1.0;  // Minimize -t (maximize t)

        // Constraints:
        // 1. Zero cone (equality): t * svec(I) + s_eq = C  (sdp_dim rows)
        // 2. PSD cone: -s + s_psd = 0 => s_psd = s  (sdp_dim rows)
        //
        // For constraint 1: t * svec(I)[i] + s[i] + slack[i] = C[i]
        // where slack is in Zero cone (so slack = 0)

        let mut triplets = Vec::new();

        // Equality constraints: t * svec(I) + s = C
        // A has coefficients for [t, s_0, ..., s_{sdp_dim-1}]
        for k in 0..n {
            let diag_idx = k * (k + 3) / 2;
            triplets.push((diag_idx, 0, 1.0));  // t coefficient on diagonals
        }
        for i in 0..sdp_dim {
            triplets.push((i, 1 + i, 1.0));  // s_i coefficient
        }

        // PSD cone constraints: -s + s_psd = 0
        for i in 0..sdp_dim {
            triplets.push((sdp_dim + i, 1 + i, -1.0));
        }

        let a = sparse::from_triplets(2 * sdp_dim, num_vars, triplets);

        let mut b = c_svec.clone();  // RHS for equality: C
        b.extend(vec![0.0; sdp_dim]);  // RHS for PSD cone: 0

        let cones = vec![
            ConeSpec::Zero { dim: sdp_dim },  // Equality constraints
            ConeSpec::Psd { n },              // PSD cone for s
        ];

        let prob = ProblemData {
            P: None,
            q,
            A: a,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        };

        let mut settings = SolverSettings::default();
        settings.max_iter = 100;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Min Eigenvalue SDP ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("t (min eigenvalue) = {:.6}", -result.obj_val);

        assert!(matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal),
            "Status should be Optimal or AlmostOptimal, got {:?}", result.status);
        // The minimum eigenvalue of C = [3,1,0; 1,2,1; 0,1,1] is approximately 0.27
        // (roots of characteristic polynomial -λ³ + 6λ² - 9λ + 2 = 0)
        let min_eig = -result.obj_val;
        assert!(min_eig > 0.1 && min_eig < 0.5,
            "Min eigenvalue should be ~0.27, got {}", min_eig);
    }
}

=== src/exp_cone_bench.rs ===
//! Benchmark suite for exponential cone problems.
//!
//! Tests convergence quality and wall-clock performance on various
//! exp cone problems including entropy maximization, KL divergence,
//! and log-sum-exp constraints.

use solver_core::linalg::sparse;
use solver_core::{ConeSpec, ProblemData, SolverSettings, SolveStatus, solve};
use std::time::Instant;

/// Entropy maximization: maximize -∑ x_i log(x_i) subject to ∑ x_i = 1, x ≥ 0
///
/// Reformulated as exponential cone problem:
/// minimize -∑ t_i subject to (t_i, x_i, u_i) ∈ K_exp, u_i = 1, ∑ x_i = 1
///
/// The exp cone K_exp = {(s0, s1, s2) : s1 * exp(s0/s1) <= s2, s1,s2 > 0}
/// is equivalent to s0 <= s1 * log(s2/s1).
///
/// With (t_i, x_i, u_i) and u_i = 1, this gives: t_i <= x_i * log(1/x_i) = -x_i * log(x_i)
/// So maximizing ∑ t_i maximizes the entropy -∑ x_i log(x_i).
pub fn entropy_maximization(n: usize) -> ProblemData {
    // Variables: [x_1, ..., x_n, t_1, ..., t_n, u_1, ..., u_n]
    let num_vars = 3 * n;

    // Objective: minimize -∑ t_i  (equivalent to maximizing ∑ t_i)
    let mut q = vec![0.0; num_vars];
    for i in 0..n {
        q[n + i] = -1.0; // Coefficients for t_i
    }

    // Constraints:
    // Rows 0..3n: n exp cones (t_i, x_i, u_i) ∈ K_exp
    // Rows 3n..4n: u_i = 1 (equality constraints)
    // Row 4n: ∑ x_i = 1 (equality constraint)
    let mut triplets = Vec::new();

    // Exp cone constraints: (t_i, x_i, u_i) ∈ K_exp
    for i in 0..n {
        let row_offset = 3 * i;
        // Row 0: -t_i + s_0 = 0  =>  s_0 = t_i
        triplets.push((row_offset, n + i, -1.0));
        // Row 1: -x_i + s_1 = 0  =>  s_1 = x_i
        triplets.push((row_offset + 1, i, -1.0));
        // Row 2: -u_i + s_2 = 0  =>  s_2 = u_i
        triplets.push((row_offset + 2, 2 * n + i, -1.0));
    }

    // Equality constraints: u_i = 1
    for i in 0..n {
        triplets.push((3 * n + i, 2 * n + i, 1.0));
    }

    // Equality constraint: ∑ x_i = 1
    let sum_row = 4 * n;
    for i in 0..n {
        triplets.push((sum_row, i, 1.0));
    }

    let a = sparse::from_triplets(4 * n + 1, num_vars, triplets);

    // RHS: [0]*3n for exp cones, [1]*n for u_i=1, [1] for sum
    let mut b = vec![0.0; 4 * n + 1];
    for i in 0..n {
        b[3 * n + i] = 1.0; // u_i = 1
    }
    b[4 * n] = 1.0; // ∑ x_i = 1

    let mut cones = Vec::new();
    for _ in 0..n {
        cones.push(ConeSpec::Exp { count: 1 });
    }
    cones.push(ConeSpec::Zero { dim: n + 1 }); // u_i = 1 and ∑ x_i = 1

    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

/// KL divergence minimization: min KL(x || p) = ∑ x_i log(x_i/p_i)
/// subject to ∑ x_i = 1, x ≥ 0
///
/// Reformulated: min ∑ t_i - ∑ x_i log(p_i)
/// where t_i >= x_i log(x_i) via exp cone constraint (-t_i, x_i, u_i) ∈ K_exp, u_i = 1
///
/// The exp cone (-t, y, z) constraint gives: y * exp(-t/y) <= z
/// With y=x_i, z=1: x_i * exp(-t_i/x_i) <= 1 → -t_i/x_i <= log(1/x_i) → t_i >= x_i log(x_i)
pub fn kl_divergence(n: usize, p: &[f64]) -> ProblemData {
    assert_eq!(p.len(), n, "p must have length n");
    assert!(p.iter().all(|&pi| pi > 0.0), "p must be positive");

    // Variables: [x_1, ..., x_n, t_1, ..., t_n, u_1, ..., u_n]
    let num_vars = 3 * n;

    // Objective: minimize ∑ t_i - ∑ x_i log(p_i)
    let mut q = vec![0.0; num_vars];
    for i in 0..n {
        q[i] = -p[i].ln(); // Coefficient for x_i
        q[n + i] = 1.0;     // Coefficient for t_i
        // u_i has zero coefficient
    }

    // Constraints:
    // Rows 0..3n: n exp cones (-t_i, x_i, u_i) ∈ K_exp
    // Rows 3n..4n: u_i = 1 (equality constraints)
    // Row 4n: ∑ x_i = 1 (equality constraint)
    let mut triplets = Vec::new();

    // Exp cone constraints: (-t_i, x_i, u_i) ∈ K_exp
    for i in 0..n {
        let row_offset = 3 * i;
        // Row 0: t_i + s_0 = 0 => s_0 = -t_i (note: positive sign for t_i!)
        triplets.push((row_offset, n + i, 1.0));
        // Row 1: -x_i + s_1 = 0 => s_1 = x_i
        triplets.push((row_offset + 1, i, -1.0));
        // Row 2: -u_i + s_2 = 0 => s_2 = u_i
        triplets.push((row_offset + 2, 2 * n + i, -1.0));
    }

    // Equality constraints: u_i = 1
    for i in 0..n {
        triplets.push((3 * n + i, 2 * n + i, 1.0));
    }

    // Equality constraint: ∑ x_i = 1
    let sum_row = 4 * n;
    for i in 0..n {
        triplets.push((sum_row, i, 1.0));
    }

    let A = sparse::from_triplets(4 * n + 1, num_vars, triplets);

    // RHS: [0]*3n for exp cones, [1]*n for u_i=1, [1] for sum
    let mut b = vec![0.0; 4 * n + 1];
    for i in 0..n {
        b[3 * n + i] = 1.0; // u_i = 1
    }
    b[4 * n] = 1.0; // ∑ x_i = 1

    let mut cones = Vec::new();
    for _ in 0..n {
        cones.push(ConeSpec::Exp { count: 1 });
    }
    cones.push(ConeSpec::Zero { dim: n + 1 }); // u_i = 1 and ∑ x_i = 1

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

/// Log-sum-exp constraint: log(∑ exp(a_i)) ≤ b
///
/// Reformulated: ∑ y_i ≤ exp(b), (a_i, 1, y_i) ∈ K_exp
pub fn log_sum_exp(n: usize, a: &[f64], b: f64) -> ProblemData {
    assert_eq!(a.len(), n);

    // Variables: [y_1, ..., y_n]
    let num_vars = n;

    // Objective: minimize 0 (feasibility problem)
    let q = vec![0.0; num_vars];

    // Constraints:
    // Rows 0..3n: n exp cones (a_i, 1, y_i) ∈ K_exp
    // Row 3n: ∑ y_i ≤ exp(b) (NonNeg cone)
    let mut triplets = Vec::new();

    for i in 0..n {
        let row_offset = 3 * i;
        // Row 0: s_0 = a_i (fixed)
        // Row 1: s_1 = 1 (fixed)
        // Row 2: -y_i + s_2 = 0
        triplets.push((row_offset + 2, i, -1.0));
    }

    // Inequality: ∑ y_i + s = exp(b)
    let ineq_row = 3 * n;
    for i in 0..n {
        triplets.push((ineq_row, i, 1.0));
    }

    let A = sparse::from_triplets(3 * n + 1, num_vars, triplets);
    let mut b_vec = Vec::new();
    for i in 0..n {
        b_vec.push(a[i]);  // s_0 = a_i
        b_vec.push(1.0);   // s_1 = 1
        b_vec.push(0.0);   // s_2 = y_i
    }
    b_vec.push(b.exp()); // ∑ y_i + s = exp(b)

    let mut cones = Vec::new();
    for _ in 0..n {
        cones.push(ConeSpec::Exp { count: 1 });
    }
    cones.push(ConeSpec::NonNeg { dim: 1 });

    ProblemData {
        P: None,
        q,
        A,
        b: b_vec,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

/// Portfolio optimization with exponential utility
///
/// maximize ∑ r_i x_i - λ ∑ x_i log(x_i)
/// subject to ∑ x_i = 1, x ≥ 0 (fully invested, long-only)
///
/// Reformulated as: minimize -∑ r_i x_i + λ ∑ t_i
/// where t_i >= x_i log(x_i) via exp cone constraint (-t_i, x_i, u_i) ∈ K_exp, u_i = 1
pub fn portfolio_exp_utility(n: usize, returns: &[f64], lambda: f64) -> ProblemData {
    assert_eq!(returns.len(), n);

    // Variables: [x_1, ..., x_n, t_1, ..., t_n, u_1, ..., u_n]
    let num_vars = 3 * n;

    // Objective: minimize -∑ r_i x_i + λ ∑ t_i
    let mut q = vec![0.0; num_vars];
    for i in 0..n {
        q[i] = -returns[i];  // -r_i for x_i
        q[n + i] = lambda;   // λ for t_i
        // u_i has zero coefficient
    }

    // Constraints:
    // Rows 0..3n: n exp cones (-t_i, x_i, u_i) ∈ K_exp
    // Rows 3n..4n: u_i = 1 (equality constraints)
    // Row 4n: ∑ x_i = 1 (equality constraint)
    let mut triplets = Vec::new();

    // Exp cone constraints: (-t_i, x_i, u_i) ∈ K_exp
    for i in 0..n {
        let row_offset = 3 * i;
        // Row 0: t_i + s_0 = 0 => s_0 = -t_i (note: positive sign for t_i!)
        triplets.push((row_offset, n + i, 1.0));
        // Row 1: -x_i + s_1 = 0 => s_1 = x_i
        triplets.push((row_offset + 1, i, -1.0));
        // Row 2: -u_i + s_2 = 0 => s_2 = u_i
        triplets.push((row_offset + 2, 2 * n + i, -1.0));
    }

    // Equality constraints: u_i = 1
    for i in 0..n {
        triplets.push((3 * n + i, 2 * n + i, 1.0));
    }

    // Equality constraint: ∑ x_i = 1
    let sum_row = 4 * n;
    for i in 0..n {
        triplets.push((sum_row, i, 1.0));
    }

    let A = sparse::from_triplets(4 * n + 1, num_vars, triplets);

    // RHS: [0]*3n for exp cones, [1]*n for u_i=1, [1] for sum
    let mut b = vec![0.0; 4 * n + 1];
    for i in 0..n {
        b[3 * n + i] = 1.0; // u_i = 1
    }
    b[4 * n] = 1.0; // ∑ x_i = 1

    let mut cones = Vec::new();
    for _ in 0..n {
        cones.push(ConeSpec::Exp { count: 1 });
    }
    cones.push(ConeSpec::Zero { dim: n + 1 }); // u_i = 1 and ∑ x_i = 1

    ProblemData {
        P: None,
        q,
        A,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    }
}

pub struct BenchResult {
    pub name: String,
    pub n: usize,
    pub status: String,
    pub iters: usize,
    pub obj_val: f64,
    pub solve_time_ms: f64,
    pub feasible: bool,
    pub optimal: bool,
}

pub fn run_exp_cone_benchmarks(verbose: bool) -> Vec<BenchResult> {
    let mut results = Vec::new();

    // Test sizes
    let sizes = vec![5, 10, 20, 50];

    for &n in &sizes {
        // Entropy maximization
        {
            let prob = entropy_maximization(n);
            let mut settings = SolverSettings::default();
            settings.verbose = verbose;
            settings.max_iter = 100;

            let start = Instant::now();
            let result = solve(&prob, &settings).unwrap();
            let elapsed = start.elapsed().as_secs_f64() * 1000.0;

            let optimal = matches!(result.status, SolveStatus::Optimal);
            let feasible = result.info.primal_res <= 1e-6 && result.info.dual_res <= 1e-6;

            results.push(BenchResult {
                name: format!("entropy_max_n{}", n),
                n,
                status: format!("{:?}", result.status),
                iters: result.info.iters,
                obj_val: result.obj_val,
                solve_time_ms: elapsed,
                feasible,
                optimal,
            });
        }

        // KL divergence (uniform prior)
        {
            let p = vec![1.0 / n as f64; n];
            let prob = kl_divergence(n, &p);
            let mut settings = SolverSettings::default();
            settings.verbose = verbose;
            settings.max_iter = 100;

            let start = Instant::now();
            let result = solve(&prob, &settings).unwrap();
            let elapsed = start.elapsed().as_secs_f64() * 1000.0;

            let optimal = matches!(result.status, SolveStatus::Optimal);
            let feasible = result.info.primal_res <= 1e-6 && result.info.dual_res <= 1e-6;

            results.push(BenchResult {
                name: format!("kl_divergence_n{}", n),
                n,
                status: format!("{:?}", result.status),
                iters: result.info.iters,
                obj_val: result.obj_val,
                solve_time_ms: elapsed,
                feasible,
                optimal,
            });
        }

        // Portfolio with exponential utility
        if n <= 20 {
            let returns: Vec<f64> = (0..n).map(|i| 0.05 + 0.02 * (i as f64) / (n as f64)).collect();
            let prob = portfolio_exp_utility(n, &returns, 0.5);
            let mut settings = SolverSettings::default();
            settings.verbose = verbose;
            settings.max_iter = 100;

            let start = Instant::now();
            let result = solve(&prob, &settings).unwrap();
            let elapsed = start.elapsed().as_secs_f64() * 1000.0;

            let optimal = matches!(result.status, SolveStatus::Optimal);
            let feasible = result.info.primal_res <= 1e-6 && result.info.dual_res <= 1e-6;

            results.push(BenchResult {
                name: format!("portfolio_exp_n{}", n),
                n,
                status: format!("{:?}", result.status),
                iters: result.info.iters,
                obj_val: result.obj_val,
                solve_time_ms: elapsed,
                feasible,
                optimal,
            });
        }
    }

    results
}

pub fn print_benchmark_table(results: &[BenchResult]) {
    println!("\n{:=<100}", "");
    println!("EXPONENTIAL CONE BENCHMARK RESULTS");
    println!("{:=<100}", "");
    println!(
        "{:<30} {:>6} {:>10} {:>8} {:>15} {:>12} {:>8}",
        "Problem", "n", "Status", "Iters", "Objective", "Time (ms)", "Quality"
    );
    println!("{:-<100}", "");

    for r in results {
        let quality = if r.optimal {
            "Optimal"
        } else if r.feasible {
            "Feasible"
        } else {
            "Infeas"
        };

        println!(
            "{:<30} {:>6} {:>10} {:>8} {:>15.6e} {:>12.2} {:>8}",
            r.name, r.n, r.status, r.iters, r.obj_val, r.solve_time_ms, quality
        );
    }

    println!("{:=<100}", "");

    // Summary statistics
    let optimal_count = results.iter().filter(|r| r.optimal).count();
    let feasible_count = results.iter().filter(|r| r.feasible).count();
    let avg_iters = results.iter().map(|r| r.iters).sum::<usize>() as f64 / results.len() as f64;
    let avg_time = results.iter().map(|r| r.solve_time_ms).sum::<f64>() / results.len() as f64;

    println!("Summary:");
    println!("  Optimal: {}/{} ({:.1}%)", optimal_count, results.len(),
             100.0 * optimal_count as f64 / results.len() as f64);
    println!("  Feasible: {}/{} ({:.1}%)", feasible_count, results.len(),
             100.0 * feasible_count as f64 / results.len() as f64);
    println!("  Avg iterations: {:.1}", avg_iters);
    println!("  Avg solve time: {:.2} ms", avg_time);
    println!("{:=<100}\n", "");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entropy_maximization_small() {
        let prob = entropy_maximization(3);
        let mut settings = SolverSettings::default();
        settings.verbose = true;
        settings.max_iter = 50;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== Entropy Maximization (n=3) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("Solution x: {:?}", &result.x[0..3]);

        // Optimal solution should be uniform: x_i = 1/3
        // Objective = -3 * (1/3) * log(1/3) = log(3) ≈ 1.0986
        assert!(result.info.primal_res <= 1e-5, "Primal residual too high");
        assert!(result.info.dual_res <= 1e-5, "Dual residual too high");
    }

    #[test]
    fn test_kl_divergence_small() {
        let n = 3;
        let p = vec![0.5, 0.3, 0.2];
        let prob = kl_divergence(n, &p);
        let mut settings = SolverSettings::default();
        settings.verbose = true;
        settings.max_iter = 50;

        let result = solve(&prob, &settings).unwrap();
        println!("\n=== KL Divergence (n=3) ===");
        println!("Status: {:?}", result.status);
        println!("Iterations: {}", result.info.iters);
        println!("Objective: {:.6}", result.obj_val);
        println!("Solution x: {:?}", &result.x[0..3]);
        println!("Target  p: {:?}", p);

        // Optimal solution should be x = p (minimize KL(x||p))
        assert!(result.info.primal_res <= 1e-5, "Primal residual too high");
        assert!(result.info.dual_res <= 1e-5, "Dual residual too high");
    }

    #[test]
    fn test_run_all_benchmarks() {
        let results = run_exp_cone_benchmarks(false);
        print_benchmark_table(&results);

        // Check that at least some problems solved optimally
        let optimal_count = results.iter().filter(|r| r.optimal).count();
        assert!(optimal_count > 0, "No problems solved optimally");
    }
}

=== src/main.rs ===
//! Benchmarking CLI for minix solver.

mod conic_benchmarks;
mod exp_cone_bench;
mod maros_meszaros;
mod qps;
mod regression;
mod sdplib;
mod solver_choice;
mod test_problems;

use clap::{Parser, Subcommand, ValueEnum};
use solver_choice::{solve_with_choice, SolverChoice};
use solver_core::{ConeSpec, ProblemData, SolveStatus, SolverSettings};
use solver_core::linalg::sparse;
use std::time::Instant;

#[derive(Parser)]
#[command(name = "solver-bench")]
#[command(about = "Benchmarking CLI for minix solver")]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

/// Available benchmark suites
#[derive(Debug, Clone, Copy, ValueEnum)]
enum BenchmarkSuite {
    /// Maros-Meszaros QP benchmark suite (136 problems)
    Mm,
    /// SDPLIB SDP benchmark suite (~90 problems)
    Sdplib,
    /// Exponential cone benchmarks (entropy, KL, portfolio)
    Exp,
}

#[derive(Subcommand)]
enum Commands {
    /// Run random generated benchmarks
    Random {
        /// Maximum iterations
        #[arg(long, default_value = "200")]
        max_iter: usize,
        /// Solver backend to use
        #[arg(long, value_enum, default_value = "ipm2")]
        solver: SolverChoice,
    },
    /// Run benchmark suite (Maros-Meszaros QP or SDPLIB SDP)
    Benchmark {
        /// Benchmark suite to run
        #[arg(long, value_enum)]
        suite: BenchmarkSuite,
        /// Path to problem files (default: auto-detect from _data/)
        #[arg(long)]
        path: Option<String>,
        /// Maximum number of problems to run
        #[arg(long)]
        limit: Option<usize>,
        /// Maximum iterations per problem
        #[arg(long, default_value = "100")]
        max_iter: usize,
        /// Run a single problem by name
        #[arg(long)]
        problem: Option<String>,
        /// Show detailed results table (MM only)
        #[arg(long)]
        table: bool,
        /// Verbose output (show iteration progress)
        #[arg(long, short)]
        verbose: bool,
        /// Solver backend to use
        #[arg(long, value_enum, default_value = "ipm2")]
        solver: SolverChoice,
        /// Run as SOCP (reformulate QP without P matrix)
        #[arg(long)]
        socp: bool,
    },
    /// Parse and show info about a QPS file
    Info {
        /// Path to QPS file
        path: String,
    },
    /// Run regression suite (local QPS cache + synthetic cases)
    Regression {
        /// Maximum iterations per problem (for passing problems)
        #[arg(long, default_value = "200")]
        max_iter: usize,
        /// Maximum iterations for expected-to-fail problems
        #[arg(long, default_value = "50")]
        max_iter_fail: usize,
        /// Require cached QPS files (fail if missing)
        #[arg(long)]
        require_cache: bool,
        /// Solver backend to use
        #[arg(long, value_enum, default_value = "ipm2")]
        solver: SolverChoice,
        /// Read performance baseline JSON and gate regressions
        #[arg(long)]
        baseline_in: Option<String>,
        /// Write performance baseline JSON
        #[arg(long)]
        baseline_out: Option<String>,
        /// Allowed regression ratio (0.2 = 20% slower)
        #[arg(long, default_value = "0.2")]
        max_regression: f64,
        /// Only run SOCP-reformulated problems (skip native QP/SDP tests)
        #[arg(long)]
        socp_only: bool,
        /// Filter to specific problem(s) by prefix (e.g., "HS" or "DUAL")
        #[arg(long)]
        filter: Option<String>,
    },
}

/// Generate a random LP:
///   minimize    c^T x
///   subject to  Ax = b
///               x >= 0
///
/// where A is m x n, with density `sparsity`.
fn generate_random_lp(n: usize, m: usize, sparsity: f64, seed: u64) -> ProblemData {
    // Simple LCG random number generator
    let mut rng_state = seed;
    let mut rand = || -> f64 {
        rng_state = rng_state.wrapping_mul(6364136223846793005).wrapping_add(1);
        ((rng_state >> 33) as f64) / (u32::MAX as f64)
    };

    // Generate cost vector c (random positive values)
    let q: Vec<f64> = (0..n).map(|_| rand() + 0.1).collect();

    let total_constraints = m + n;

    // Generate A part (m x n with sparsity)
    let mut triplets = Vec::new();
    for i in 0..m {
        for j in 0..n {
            if rand() < sparsity {
                let val = 2.0 * rand() - 1.0;
                triplets.push((i, j, val));
            }
        }
        // Ensure at least one nonzero per row for feasibility
        let j = (rand() * n as f64) as usize;
        let j = j.min(n - 1);
        triplets.push((i, j, rand() + 0.5));
    }

    // Add -I part for bound constraints
    for j in 0..n {
        triplets.push((m + j, j, -1.0));
    }

    let a = sparse::from_triplets(total_constraints, n, triplets);

    // Generate RHS b
    let x_feas: Vec<f64> = (0..n).map(|_| rand() + 0.1).collect();
    let mut b = vec![0.0; total_constraints];

    for col in 0..n {
        if let Some(col_view) = a.outer_view(col) {
            for (row, &val) in col_view.iter() {
                if row < m {
                    b[row] += val * x_feas[col];
                }
            }
        }
    }

    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![
            ConeSpec::Zero { dim: m },
            ConeSpec::NonNeg { dim: n },
        ],
        var_bounds: None,
        integrality: None,
    }
}

/// Generate a portfolio optimization LP
fn generate_portfolio_lp(n: usize, seed: u64) -> ProblemData {
    let mut rng_state = seed;
    let mut rand = || -> f64 {
        rng_state = rng_state.wrapping_mul(6364136223846793005).wrapping_add(1);
        ((rng_state >> 33) as f64) / (u32::MAX as f64)
    };

    let q: Vec<f64> = (0..n).map(|_| -(rand() * 0.2 + 0.05)).collect();

    let mut triplets = Vec::new();

    // Row 0: sum constraint
    for j in 0..n {
        triplets.push((0, j, 1.0));
    }

    // Rows 1..n+1: -I for bounds
    for j in 0..n {
        triplets.push((1 + j, j, -1.0));
    }

    let a = sparse::from_triplets(1 + n, n, triplets);
    let mut b = vec![0.0; 1 + n];
    b[0] = 1.0;

    ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones: vec![
            ConeSpec::Zero { dim: 1 },
            ConeSpec::NonNeg { dim: n },
        ],
        var_bounds: None,
        integrality: None,
    }
}

fn run_benchmark(name: &str, prob: &ProblemData, settings: &SolverSettings, solver: SolverChoice) {
    let n = prob.num_vars();
    let m = prob.num_constraints();
    let nnz = prob.A.nnz();

    println!("\n{}", "=".repeat(60));
    println!("{}", name);
    println!("{}", "=".repeat(60));
    println!("Variables (n):    {}", n);
    println!("Constraints (m):  {}", m);
    println!("A nonzeros:       {} ({:.2}% dense)", nnz, 100.0 * nnz as f64 / (n * m) as f64);
    println!();

    let start = Instant::now();
    let result = solve_with_choice(prob, settings, solver);
    let elapsed = start.elapsed();

    match result {
        Ok(res) => {
            println!("Status:           {:?}", res.status);
            println!("Iterations:       {}", res.info.iters);
            println!("Objective:        {:.6e}", res.obj_val);
            println!("Final μ:          {:.6e}", res.info.mu);
            println!("Solve time:       {:.3} ms", elapsed.as_secs_f64() * 1000.0);
            println!("Time/iteration:   {:.3} ms", elapsed.as_secs_f64() * 1000.0 / res.info.iters as f64);
        }
        Err(e) => {
            println!("ERROR: {}", e);
        }
    }
}

fn run_random_benchmarks(max_iter: usize, solver: SolverChoice) {
    println!("Minix Solver Benchmarks");
    println!("=======================\n");

    let settings = SolverSettings {
        verbose: false,
        max_iter,
        tol_feas: 1e-6,
        tol_gap: 1e-6,
        ..Default::default()
    };

    // Portfolio LPs
    let prob = generate_portfolio_lp(50, 12345);
    run_benchmark("Portfolio LP (n=50)", &prob, &settings, solver);

    let prob = generate_portfolio_lp(200, 12345);
    run_benchmark("Portfolio LP (n=200)", &prob, &settings, solver);

    let prob = generate_portfolio_lp(500, 12345);
    run_benchmark("Portfolio LP (n=500)", &prob, &settings, solver);

    // Random LPs
    let prob = generate_random_lp(100, 50, 0.3, 12345);
    run_benchmark("Random LP (n=100, m=50, 30% dense)", &prob, &settings, solver);

    let prob = generate_random_lp(500, 200, 0.1, 12345);
    run_benchmark("Random LP (n=500, m=200, 10% dense)", &prob, &settings, solver);

    let prob = generate_random_lp(1000, 500, 0.05, 12345);
    run_benchmark("Random LP (n=1000, m=500, 5% dense)", &prob, &settings, solver);

    println!("\n{}", "=".repeat(60));
    println!("Benchmarks complete");
    println!("{}", "=".repeat(60));
}

fn run_maros_meszaros(
    limit: Option<usize>,
    max_iter: usize,
    problem: Option<String>,
    show_table: bool,
    solver: SolverChoice,
    socp: bool,
) {
    // Check for direct mode via environment variable
    let direct_mode = std::env::var("MINIX_DIRECT_MODE")
        .map(|v| v != "0")
        .unwrap_or(false);

    let settings = SolverSettings {
        verbose: false,
        max_iter,
        tol_feas: 1e-8,
        tol_gap: 1e-8,
        direct_mode,
        ..Default::default()
    };

    if let Some(name) = problem {
        // Run single problem
        if socp {
            println!("Running single problem as SOCP: {}", name);
            match maros_meszaros::load_problem(&name) {
                Ok(qps) => {
                    match qps.to_socp_form() {
                        Ok(prob) => {
                            println!("SOCP Variables:   {}", prob.num_vars());
                            println!("SOCP Constraints: {}", prob.num_constraints());
                            println!("SOCP Cones:       {:?}", prob.cones);

                            let start = Instant::now();
                            let result = solve_with_choice(&prob, &settings, solver);
                            let elapsed = start.elapsed();

                            match result {
                                Ok(res) => {
                                    println!("Status:     {:?}", res.status);
                                    println!("Iterations: {}", res.info.iters);
                                    println!("Objective:  {:.6e}", res.obj_val);
                                    println!("Final μ:    {:.6e}", res.info.mu);
                                    println!("Time:       {:.3} ms", elapsed.as_secs_f64() * 1000.0);
                                }
                                Err(e) => println!("Solve error: {}", e),
                            }
                        }
                        Err(e) => println!("SOCP conversion error: {}", e),
                    }
                }
                Err(e) => println!("Load error: {}", e),
            }
        } else {
            println!("Running single problem: {}", name);
            let result = maros_meszaros::run_single(&name, &settings, solver);

            if let Some(err) = &result.error {
                println!("Error: {}", err);
            } else {
                println!("Status:     {:?}", result.status);
                println!("Variables:  {}", result.n);
                println!("Constraints:{}", result.m);
                println!("Iterations: {}", result.iterations);
                println!("Objective:  {:.6e}", result.obj_val);
                println!("Final μ:    {:.6e}", result.mu);
                println!("Time:       {:.3} ms", result.solve_time_ms);
            }
        }
    } else {
        // Run full suite
        println!("Running Maros-Meszaros QP Benchmark Suite");
        println!("=========================================\n");

        let results = maros_meszaros::run_full_suite(&settings, limit, solver);
        let summary = maros_meszaros::compute_summary(&results);

        if show_table {
            maros_meszaros::print_results_table(&results);
        }

        maros_meszaros::print_summary(&summary);
    }
}

fn show_qps_info(path: &str) {
    match qps::parse_qps(path) {
        Ok(qps) => {
            println!("QPS Problem: {}", qps.name);
            println!("Variables:   {}", qps.n);
            println!("Constraints: {}", qps.m);
            println!("Q nonzeros:  {}", qps.p_triplets.len());
            println!("A nonzeros:  {}", qps.a_triplets.len());

            println!("\nVariable bounds:");
            for (i, name) in qps.var_names.iter().enumerate().take(5) {
                println!("  {}: [{}, {}]", name, qps.var_lower[i], qps.var_upper[i]);
            }
            if qps.n > 5 {
                println!("  ... ({} more)", qps.n - 5);
            }

            println!("\nConstraint bounds:");
            for (i, name) in qps.con_names.iter().enumerate().take(5) {
                println!("  {}: [{}, {}]", name, qps.con_lower[i], qps.con_upper[i]);
            }
            if qps.m > 5 {
                println!("  ... ({} more)", qps.m - 5);
            }

            // Try converting to conic form
            match qps.to_problem_data() {
                Ok(prob) => {
                    println!("\nConic form:");
                    println!("  Variables:   {}", prob.num_vars());
                    println!("  Constraints: {}", prob.num_constraints());
                    println!("  Cones:       {:?}", prob.cones);
                }
                Err(e) => {
                    println!("\nFailed to convert to conic form: {}", e);
                }
            }
        }
        Err(e) => {
            eprintln!("Error parsing QPS file: {}", e);
        }
    }
}

fn run_regression_suite(
    max_iter: usize,
    max_iter_fail: usize,
    solver: SolverChoice,
    require_cache: bool,
    baseline_in: Option<String>,
    baseline_out: Option<String>,
    max_regression: f64,
    socp_only: bool,
    filter: Option<String>,
) {
    let mut settings = SolverSettings::default();
    settings.max_iter = max_iter;

    let results = regression::run_regression_suite(&settings, solver, require_cache, max_iter_fail, socp_only, filter.as_deref());
    let mut failed = 0usize;
    let mut skipped = 0usize;

    // For SOCP tests, results are already printed by run_socp_tests()
    // Just count failures and print summary
    if socp_only {
        for res in &results {
            if res.skipped {
                skipped += 1;
            } else if !matches!(res.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal) {
                failed += 1;
            }
        }
        println!("summary: total={} failed={} skipped={}", results.len(), failed, skipped);
        return;
    }

    // SDPLIB problem names (use looser tolerances)
    let sdp_problems: std::collections::HashSet<&str> = [
        "control1", "control2", "hinf1", "hinf4", "hinf10", "hinf11", "hinf14",
        "theta1", "truss1", "truss3", "truss4", "truss5", "truss6", "truss7",
    ].iter().copied().collect();

    for res in &results {
        if res.skipped {
            skipped += 1;
            println!("{}: SKIP (missing cache)", res.name);
            continue;
        }
        // Accept both Optimal and AlmostOptimal (for numerically challenging SOCP)
        let status_ok = matches!(res.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal);
        if !status_ok
            || !res.rel_p.is_finite()
            || !res.rel_d.is_finite()
            || !res.gap_rel.is_finite()
        {
            failed += 1;
            println!(
                "{}: FAIL status={:?} rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e} {}",
                res.name,
                res.status,
                res.rel_p,
                res.rel_d,
                res.gap_rel,
                res.error.as_deref().unwrap_or(""),
            );
            continue;
        }

        // Use practical tolerances for unscaled metrics
        // SDP problems (PSD cones) have inherently worse conditioning
        // AlmostOptimal uses Clarabel's reduced tolerances
        let base_tol_feas = if sdp_problems.contains(res.name.as_str()) { 1e-4 } else { 1e-6 };
        let base_tol_gap = 1e-3;
        let (tol_feas, tol_gap) = if res.status == SolveStatus::AlmostOptimal {
            // Clarabel's reduced tolerances for AlmostOptimal
            (1e-4, 5e-5)  // reduced_tol_feas, reduced_tol_gap_rel
        } else {
            (base_tol_feas, base_tol_gap)
        };
        if res.rel_p > tol_feas || res.rel_d > tol_feas || res.gap_rel > tol_gap {
            failed += 1;
            println!(
                "{}: FAIL rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e}",
                res.name,
                res.rel_p,
                res.rel_d,
                res.gap_rel,
            );
        } else {
            println!(
                "{}: OK iters={} rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e}",
                res.name,
                res.iterations,
                res.rel_p,
                res.rel_d,
                res.gap_rel,
            );
        }
    }

    println!(
        "summary: total={} failed={} skipped={}",
        results.len(),
        failed,
        skipped
    );

    if failed == 0 {
        if let Some(path) = baseline_out.as_ref() {
            let summary = regression::perf_summary(&results);
            let payload = serde_json::to_string_pretty(&summary)
                .expect("failed to serialize perf summary");
            if let Err(e) = std::fs::write(path, payload) {
                eprintln!("failed to write baseline {}: {}", path, e);
                std::process::exit(1);
            }
        }

        if let Some(path) = baseline_in.as_ref() {
            let Ok(contents) = std::fs::read_to_string(path) else {
                eprintln!("failed to read baseline {}", path);
                std::process::exit(1);
            };
            let baseline: regression::PerfSummary = match serde_json::from_str(&contents) {
                Ok(val) => val,
                Err(e) => {
                    eprintln!("failed to parse baseline {}: {}", path, e);
                    std::process::exit(1);
                }
            };
            let summary = regression::perf_summary(&results);
            let perf_failures =
                regression::compare_perf_baseline(&baseline, &summary, max_regression);
            if !perf_failures.is_empty() {
                for msg in perf_failures {
                    eprintln!("perf regression: {}", msg);
                }
                std::process::exit(1);
            }
        }
    }

    if failed > 0 || (require_cache && skipped > 0) {
        std::process::exit(1);
    }
}

fn run_exp_benchmarks(_max_iter: usize, verbose: bool) {
    use exp_cone_bench::{run_exp_cone_benchmarks, print_benchmark_table};

    println!("Exponential Cone Benchmark Suite");
    println!("=================================\n");

    let results = run_exp_cone_benchmarks(verbose);
    print_benchmark_table(&results);
}

fn run_sdplib_benchmarks(
    path: Option<String>,
    limit: Option<usize>,
    max_iter: usize,
    problem: Option<String>,
    download: Option<String>,
    verbose: bool,
) {
    use sdplib::{load_sdpa_file, sdpa_to_conic_selected, sdplib_reference_values, solve_sdpa, SdpaForm};
    use std::path::PathBuf;

    // Handle download request
    if let Some(dir) = download {
        println!("To download SDPLIB problems:");
        println!("  curl -L http://euler.nmt.edu/~brian/sdplib/sdplib.zip -o sdplib.zip");
        println!("  unzip sdplib.zip -d {}", dir);
        println!("\nAlternatively, visit: http://euler.nmt.edu/~brian/sdplib/sdplib.html");
        return;
    }

    let settings = SolverSettings {
        verbose,
        max_iter,
        tol_feas: 1e-6,
        tol_gap: 1e-6,
        ..Default::default()
    };

    let reference = sdplib_reference_values();

    // Single problem mode
    if let Some(name) = problem {
        let file_path = if let Some(ref dir) = path {
            PathBuf::from(dir).join(format!("{}.dat-s", name))
        } else {
            PathBuf::from(format!("{}.dat-s", name))
        };

        if !file_path.exists() {
            eprintln!("Problem file not found: {}", file_path.display());
            return;
        }

        println!("Running single problem: {}", name);

        match load_sdpa_file(&file_path) {
            Ok(sdpa) => {
                println!("Problem: {}", sdpa.name);
                println!("Constraints (m): {}", sdpa.m_dim);
                println!("Blocks: {:?}", sdpa.block_struct);

                match sdpa_to_conic_selected(&sdpa) {
                    Ok((prob, form)) => {
                        let var_label = match form {
                            SdpaForm::Primal => "Variables (svec)",
                            SdpaForm::Dual => "Variables (dual y)",
                        };
                        println!("Form: {:?}", form);
                        println!("{}: {}", var_label, prob.num_vars());

                        let start = Instant::now();
                        match solve_sdpa(&sdpa, &settings) {
                            Ok(result) => {
                                let elapsed = start.elapsed();
                                println!("Status: {:?}", result.status);
                                println!("Primal obj: {:.6e}", result.primal_obj);
                                println!("Dual obj: {:.6e}", result.dual_obj);
                                println!("Iterations: {}", result.iterations);
                                println!("Time: {:.3} ms", elapsed.as_secs_f64() * 1000.0);

                                if let Some(&ref_val) = reference.get(sdpa.name.as_str()) {
                                    let rel_err = (result.primal_obj - ref_val).abs() / (1.0 + ref_val.abs());
                                    println!("Reference: {:.6e}", ref_val);
                                    println!("Rel error: {:.2e}", rel_err);
                                }
                            }
                            Err(e) => println!("Solve error: {}", e),
                        }
                    }
                    Err(e) => println!("Conversion error: {}", e),
                }
            }
            Err(e) => println!("Parse error: {}", e),
        }
        return;
    }

    // Full benchmark mode
    let dir = path.unwrap_or_else(|| ".".to_string());
    let dir_path = PathBuf::from(&dir);

    if !dir_path.exists() {
        eprintln!("Directory not found: {}", dir);
        eprintln!("\nTo run SDPLIB benchmarks, specify the path to SDPLIB .dat-s files:");
        eprintln!("  cargo run --release -p solver-bench -- sdplib --path /path/to/sdplib");
        return;
    }

    // Find all .dat-s files
    let mut files: Vec<PathBuf> = std::fs::read_dir(&dir_path)
        .expect("Failed to read directory")
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p: &PathBuf| p.extension().map_or(false, |e| e == "dat-s"))
        .collect();

    files.sort();

    if files.is_empty() {
        eprintln!("No .dat-s files found in {}", dir);
        return;
    }

    let files: Vec<_> = if let Some(n) = limit {
        files.into_iter().take(n).collect()
    } else {
        files
    };

    println!("SDPLIB Benchmark Suite");
    println!("======================");
    println!("Found {} problems in {}\n", files.len(), dir);

    // Results table
    println!(
        "{:<20} {:>8} {:>8} {:>12} {:>12} {:>10} {:>8}",
        "Problem", "Status", "Iters", "Primal Obj", "Reference", "Rel Err", "Time(ms)"
    );
    println!("{}", "-".repeat(90));

    let mut total = 0;
    let mut optimal = 0;
    let mut almost_optimal = 0;
    let mut failed = 0;
    let mut total_time = 0.0;

    for file in &files {
        let name = file.file_stem().unwrap().to_str().unwrap();
        total += 1;

        match load_sdpa_file(file) {
            Ok(sdpa) => {
                let start = Instant::now();
                match solve_sdpa(&sdpa, &settings) {
                    Ok(result) => {
                        let elapsed = start.elapsed().as_secs_f64() * 1000.0;
                        total_time += elapsed;

                        let status_str = match result.status {
                            SolveStatus::Optimal => {
                                optimal += 1;
                                "Optimal"
                            }
                            SolveStatus::AlmostOptimal => {
                                almost_optimal += 1;
                                "Almost"
                            }
                            _ => {
                                failed += 1;
                                "FAILED"
                            }
                        };

                        let (ref_str, err_str) = if let Some(&ref_val) = reference.get(name) {
                            let rel_err = (result.primal_obj - ref_val).abs() / (1.0 + ref_val.abs());
                            (format!("{:.4e}", ref_val), format!("{:.2e}", rel_err))
                        } else {
                            ("-".to_string(), "-".to_string())
                        };

                        println!(
                            "{:<20} {:>8} {:>8} {:>12.4e} {:>12} {:>10} {:>8.1}",
                            name, status_str, result.iterations, result.primal_obj, ref_str, err_str, elapsed
                        );
                    }
                    Err(e) => {
                        failed += 1;
                        println!("{:<20} {:>8} {:>8} {:>12} {:>12} {:>10} {:>8}", name, "ERROR", "-", "-", "-", "-", "-");
                        eprintln!("  Error: {}", e);
                    }
                }
            }
            Err(e) => {
                failed += 1;
                println!("{:<20} {:>8} {:>8} {:>12} {:>12} {:>10} {:>8}", name, "PARSE", "-", "-", "-", "-", "-");
                eprintln!("  Parse error: {}", e);
            }
        }
    }

    println!("{}", "-".repeat(90));
    println!("\nSummary:");
    println!("  Total:        {}", total);
    println!("  Optimal:      {} ({:.1}%)", optimal, 100.0 * optimal as f64 / total as f64);
    println!("  Almost:       {} ({:.1}%)", almost_optimal, 100.0 * almost_optimal as f64 / total as f64);
    println!("  Failed:       {} ({:.1}%)", failed, 100.0 * failed as f64 / total as f64);
    println!("  Total time:   {:.1} ms", total_time);
    println!("  Avg time:     {:.1} ms/problem", total_time / total as f64);
}

fn main() {
    let cli = Cli::parse();

    match cli.command {
        Some(Commands::Random { max_iter, solver }) => {
            run_random_benchmarks(max_iter, solver);
        }
        Some(Commands::Benchmark { suite, path, limit, max_iter, problem, table, verbose, solver, socp }) => {
            match suite {
                BenchmarkSuite::Mm => {
                    // Auto-detect path for Maros-Meszaros
                    let _path = path; // MM uses its own path logic via maros_meszaros module
                    run_maros_meszaros(limit, max_iter, problem, table, solver, socp);
                }
                BenchmarkSuite::Sdplib => {
                    // Auto-detect path for SDPLIB
                    let sdplib_path = path.or_else(|| {
                        let default = std::path::Path::new("_data/sdplib");
                        if default.exists() {
                            Some("_data/sdplib".to_string())
                        } else {
                            None
                        }
                    });
                    run_sdplib_benchmarks(sdplib_path, limit, max_iter, problem, None, verbose);
                }
                BenchmarkSuite::Exp => {
                    run_exp_benchmarks(max_iter, verbose);
                }
            }
        }
        Some(Commands::Info { path }) => {
            show_qps_info(&path);
        }
        Some(Commands::Regression {
            max_iter,
            max_iter_fail,
            require_cache,
            solver,
            baseline_in,
            baseline_out,
            max_regression,
            socp_only,
            filter,
        }) => {
            run_regression_suite(
                max_iter,
                max_iter_fail,
                solver,
                require_cache,
                baseline_in,
                baseline_out,
                max_regression,
                socp_only,
                filter,
            );
        }
        None => {
            // Default: run random benchmarks with ipm1
            run_random_benchmarks(200, SolverChoice::Ipm1);
        }
    }
}

=== src/maros_meszaros.rs ===
//! Maros-Meszaros QP benchmark suite runner.
//!
//! Downloads and runs the standard Maros-Meszaros test set of 138 QP problems.

use std::fs;
use std::path::PathBuf;
use std::time::Instant;

use anyhow::{Context, Result};
use solver_core::{ProblemData, SolveResult, SolveStatus, SolverSettings};

use crate::solver_choice::{solve_with_choice, SolverChoice};
use crate::qps::{parse_qps, QpsProblem};

/// URL for Maros-Meszaros QPS files (from GitHub mirror)
const MM_BASE_URL: &str = "https://raw.githubusercontent.com/YimingYAN/QP-Test-Problems/master/QPS_Files";

/// Known Maros-Meszaros problem names (138 problems)
const MM_PROBLEMS: &[&str] = &[
    "AUG2D", "AUG2DC", "AUG2DCQP", "AUG2DQP", "AUG3D", "AUG3DC", "AUG3DCQP", "AUG3DQP",
    "BOYD1", "BOYD2", "CONT-050", "CONT-100", "CONT-101", "CONT-200", "CONT-201", "CONT-300",
    "CVXQP1_L", "CVXQP1_M", "CVXQP1_S", "CVXQP2_L", "CVXQP2_M", "CVXQP2_S", "CVXQP3_L",
    "CVXQP3_M", "CVXQP3_S", "DPKLO1", "DTOC3", "DUAL1", "DUAL2", "DUAL3", "DUAL4", "DUALC1",
    "DUALC2", "DUALC5", "DUALC8", "EXDATA", "GOULDQP2", "GOULDQP3", "HS118", "HS21", "HS268",
    "HS35", "HS35MOD", "HS51", "HS52", "HS53", "HS76", "HUES-MOD", "HUESTIS", "KSIP",
    "LASER", "LISWET1", "LISWET10", "LISWET11", "LISWET12", "LISWET2", "LISWET3", "LISWET4",
    "LISWET5", "LISWET6", "LISWET7", "LISWET8", "LISWET9", "LOTSCHD", "MOSARQP1", "MOSARQP2",
    "POWELL20", "PRIMAL1", "PRIMAL2", "PRIMAL3", "PRIMAL4", "PRIMALC1", "PRIMALC2", "PRIMALC5",
    "PRIMALC8", "Q25FV47", "QADLITTL", "QAFIRO", "QBANDM", "QBEACONF", "QBORE3D", "QBRANDY",
    "QCAPRI", "QE226", "QETAMACR", "QFFFFF80", "QFORPLAN", "QGFRDXPN", "QGROW15", "QGROW22",
    "QGROW7", "QISRAEL", "QPCBLEND", "QPCBOEI1", "QPCBOEI2", "QPCSTAIR", "QPILOTNO", "QRECIPE",
    "QSC205", "QSCAGR25", "QSCAGR7", "QSCFXM1", "QSCFXM2", "QSCFXM3", "QSCORPIO", "QSCRS8",
    "QSCSD1", "QSCSD6", "QSCSD8", "QSCTAP1", "QSCTAP2", "QSCTAP3", "QSEBA", "QSHARE1B",
    "QSHARE2B", "QSHELL", "QSHIP04L", "QSHIP04S", "QSHIP08L", "QSHIP08S", "QSHIP12L", "QSHIP12S",
    "QSIERRA", "QSTAIR", "QSTANDAT", "S268", "STADAT1", "STADAT2", "STADAT3", "STCQP1",
    "STCQP2", "TAME", "UBH1", "VALUES", "YAO", "ZECEVIC2",
];

/// Get the list of all Maros-Meszaros problem names
pub fn mm_problem_names() -> &'static [&'static str] {
    MM_PROBLEMS
}

#[inline]
fn inf_norm(v: &[f64]) -> f64 {
    v.iter()
        .map(|x| x.abs())
        .fold(0.0_f64, f64::max)
}

#[inline]
fn dot(a: &[f64], b: &[f64]) -> f64 {
    debug_assert_eq!(a.len(), b.len());
    a.iter().zip(b.iter()).map(|(ai, bi)| ai * bi).sum()
}

fn print_diagnostics(name: &str, prob: &ProblemData, res: &SolveResult) {
    let n = prob.num_vars();
    let m = prob.num_constraints();

    let mut r_p = res.s.clone();
    for i in 0..m {
        r_p[i] -= prob.b[i];
    }
    for (&val, (row, col)) in prob.A.iter() {
        r_p[row] += val * res.x[col];
    }

    let mut p_x = vec![0.0; n];
    if let Some(ref p) = prob.P {
        for col in 0..n {
            if let Some(col_view) = p.outer_view(col) {
                for (row, &val) in col_view.iter() {
                    if row == col {
                        p_x[row] += val * res.x[col];
                    } else {
                        p_x[row] += val * res.x[col];
                        p_x[col] += val * res.x[row];
                    }
                }
            }
        }
    }

    let mut r_d = vec![0.0; n];
    for i in 0..n {
        r_d[i] = p_x[i] + prob.q[i];
    }
    for (&val, (row, col)) in prob.A.iter() {
        r_d[col] += val * res.z[row];
    }

    let rp_inf = inf_norm(&r_p);
    let rd_inf = inf_norm(&r_d);
    let x_inf = inf_norm(&res.x);
    let s_inf = inf_norm(&res.s);
    let z_inf = inf_norm(&res.z);
    let b_inf = inf_norm(&prob.b);
    let q_inf = inf_norm(&prob.q);
    let primal_scale = (b_inf + x_inf + s_inf).max(1.0);
    let dual_scale = (q_inf + x_inf + z_inf).max(1.0);

    let xpx = dot(&res.x, &p_x);
    let qtx = dot(&prob.q, &res.x);
    let btz = dot(&prob.b, &res.z);
    let primal_obj = 0.5 * xpx + qtx;
    let dual_obj = -0.5 * xpx - btz;
    let gap = (primal_obj - dual_obj).abs();
    let gap_scale = primal_obj.abs().max(dual_obj.abs()).max(1.0);

    let rel_p = rp_inf / primal_scale;
    let rel_d = rd_inf / dual_scale;
    let tol_feas = 1e-8;

    println!("Diagnostics for {}:", name);
    println!(
        "  r_p_inf={:.3e} (scale {:.3e}), r_d_inf={:.3e} (scale {:.3e})",
        rp_inf, primal_scale, rd_inf, dual_scale
    );
    println!(
        "  rel_p={:.3e}, rel_d={:.3e}",
        rel_p, rel_d
    );

    // Print top violating rows for primal residual with detailed breakdown
    let primal_ok = rel_p <= tol_feas;
    if !primal_ok {
        // Compute Ax separately (r_p = Ax + s - b, so Ax = r_p - s + b)
        let mut ax = vec![0.0; m];
        for i in 0..m {
            ax[i] = r_p[i] - res.s[i] + prob.b[i];
        }

        // Compute row norms of A
        let mut row_norms = vec![0.0f64; m];
        for (&val, (row, _col)) in prob.A.iter() {
            row_norms[row] = row_norms[row].max(val.abs());
        }

        println!("  top |r_p| rows (detailed):");
        let mut idxs: Vec<usize> = (0..m).collect();
        idxs.sort_by(|&i, &j| {
            r_p[j].abs().partial_cmp(&r_p[i].abs()).unwrap_or(std::cmp::Ordering::Equal)
        });
        for &idx in idxs.iter().take(5.min(m)) {
            println!(
                "    row[{:>4}]: rp={:+.3e}  b={:+.3e}  Ax={:+.3e}  s={:+.3e}  row_norm={:.3e}",
                idx, r_p[idx], prob.b[idx], ax[idx], res.s[idx], row_norms[idx]
            );
        }
    }

    // Print top violating components for dual residual with column analysis
    let dual_ok = rel_d <= tol_feas;
    if !dual_ok {
        // Compute column densities and norms for A
        let mut col_nnz = vec![0usize; n];
        let mut col_norms = vec![0.0f64; n];
        for (&val, (_row, col)) in prob.A.iter() {
            col_nnz[col] += 1;
            col_norms[col] = col_norms[col].max(val.abs());
        }

        // Check P diagonal entries
        let mut p_diag = vec![0.0f64; n];
        if let Some(ref p) = prob.P {
            for col in 0..n {
                if let Some(col_view) = p.outer_view(col) {
                    for (row, &val) in col_view.iter() {
                        if row == col {
                            p_diag[col] = val;
                        }
                    }
                }
            }
        }

        println!("  top |r_d| components (with structure):");
        let mut idxs: Vec<usize> = (0..n).collect();
        idxs.sort_by(|&i, &j| {
            r_d[j].abs().partial_cmp(&r_d[i].abs()).unwrap_or(std::cmp::Ordering::Equal)
        });
        for &idx in idxs.iter().take(5.min(n)) {
            // Compute A^T z contribution for this variable and analyze constraint structure
            let mut atz_j = 0.0;
            let mut constraint_info: Vec<(usize, f64, f64, f64)> = Vec::new(); // (row, a_val, z, s)
            for (&val, (row, col)) in prob.A.iter() {
                if col == idx {
                    atz_j += val * res.z[row];
                    constraint_info.push((row, val, res.z[row], res.s[row]));
                }
            }
            println!(
                "    rd[{:>4}]={:+.3e}  q={:+.3e}  Px={:+.3e}  A^Tz={:+.3e}  A_nnz={}  P_diag={:.2e}",
                idx, r_d[idx], prob.q[idx], p_x[idx], atz_j, col_nnz[idx], p_diag[idx]
            );
            // Show constraint details for first problematic variable only
            if idx == idxs[0] && col_nnz[idx] <= 10 {
                for (row, a_val, z_val, s_val) in &constraint_info {
                    println!(
                        "      row {:>4}: A={:+.3e} z={:+.3e} s={:.3e} contrib={:+.3e}",
                        row, a_val, z_val, s_val, a_val * z_val
                    );
                }
            }
        }
    }

    println!(
        "  gap={:.3e}, gap_rel={:.3e}, obj_p={:.3e}, obj_d={:.3e}",
        gap,
        gap / gap_scale,
        primal_obj,
        dual_obj
    );
}

/// Result of running a single benchmark problem
#[derive(Debug, Clone)]
pub struct BenchmarkResult {
    /// Problem name
    pub name: String,
    /// Number of variables
    pub n: usize,
    /// Number of constraints
    pub m: usize,
    /// Solve status
    pub status: SolveStatus,
    /// Number of iterations
    pub iterations: usize,
    /// Objective value
    pub obj_val: f64,
    /// Final mu
    pub mu: f64,
    /// Solve time in milliseconds
    pub solve_time_ms: f64,
    /// Error message if any
    pub error: Option<String>,
}

/// Summary statistics for benchmark run
#[derive(Debug, Clone)]
pub struct BenchmarkSummary {
    /// Total problems attempted
    pub total: usize,
    /// Problems solved to optimality
    pub optimal: usize,
    /// Problems solved to almost optimal (reduced accuracy)
    pub almost_optimal: usize,
    /// Problems hitting max iterations
    pub max_iters: usize,
    /// Problems with numerical errors
    pub numerical_errors: usize,
    /// Problems that failed to parse
    pub parse_errors: usize,
    /// Total solve time in seconds
    pub total_time_s: f64,
    /// Geometric mean of iterations (for solved problems)
    pub geom_mean_iters: f64,
    /// Geometric mean of solve times (shifted, for solved problems)
    pub geom_mean_time_ms: f64,
}

/// Get the cache directory for benchmark problems
fn get_cache_dir() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".cache").join("minix-bench").join("maros-meszaros")
}

pub fn find_local_qps(name: &str) -> Option<PathBuf> {
    let local_paths = [
        PathBuf::from(format!("{}.QPS", name)),
        PathBuf::from(format!("{}.qps", name)),
        PathBuf::from(format!("data/{}.QPS", name)),
        PathBuf::from(format!("data/{}.qps", name)),
    ];

    for path in &local_paths {
        if path.exists() {
            return Some(path.clone());
        }
    }

    let cache_dir = get_cache_dir();
    let cached_path = cache_dir.join(format!("{}.QPS", name));
    if cached_path.exists() {
        return Some(cached_path);
    }

    None
}

pub fn load_local_problem(name: &str) -> Result<QpsProblem> {
    let Some(path) = find_local_qps(name) else {
        return Err(anyhow::anyhow!("No local QPS file found for {}", name));
    };

    parse_qps(path)
}

/// Download a QPS file if not cached
fn download_qps(name: &str) -> Result<PathBuf> {
    let cache_dir = get_cache_dir();
    fs::create_dir_all(&cache_dir)?;

    let filename = format!("{}.QPS", name);
    let cached_path = cache_dir.join(&filename);

    if cached_path.exists() {
        return Ok(cached_path);
    }

    // Try downloading from GitHub mirror (no .gz)
    let url = format!("{}/{}.QPS", MM_BASE_URL, name);

    eprintln!("Downloading {}...", name);

    let output = std::process::Command::new("curl")
        .args(["-sL", "--max-time", "30", &url])
        .output()
        .context("Failed to run curl")?;

    if output.status.success() && !output.stdout.is_empty() {
        // Check if it's valid QPS content (starts with NAME or has ROWS section)
        let content = String::from_utf8_lossy(&output.stdout);
        if content.contains("ROWS") || content.starts_with("NAME") {
            fs::write(&cached_path, &output.stdout)?;
            return Ok(cached_path);
        }
    }

    // Try lowercase
    let url = format!("{}/{}.qps", MM_BASE_URL, name);
    let output = std::process::Command::new("curl")
        .args(["-sL", "--max-time", "30", &url])
        .output()
        .context("Failed to run curl")?;

    if output.status.success() && !output.stdout.is_empty() {
        let content = String::from_utf8_lossy(&output.stdout);
        if content.contains("ROWS") || content.starts_with("NAME") {
            fs::write(&cached_path, &output.stdout)?;
            return Ok(cached_path);
        }
    }

    Err(anyhow::anyhow!("Failed to download {} - file not found or invalid", name))
}

/// Load a QPS problem from file or URL
pub fn load_problem(name: &str) -> Result<QpsProblem> {
    if let Ok(prob) = load_local_problem(name) {
        return Ok(prob);
    }

    // Try cache or download
    let path = download_qps(name)?;
    parse_qps(&path)
}

/// Run a single benchmark problem
pub fn run_single(name: &str, settings: &SolverSettings, solver: SolverChoice) -> BenchmarkResult {
    // Load and parse problem
    let qps = match load_problem(name) {
        Ok(q) => q,
        Err(e) => {
            return BenchmarkResult {
                name: name.to_string(),
                n: 0,
                m: 0,
                status: SolveStatus::NumericalError,
                iterations: 0,
                obj_val: f64::NAN,
                mu: f64::NAN,
                solve_time_ms: 0.0,
                error: Some(format!("Parse error: {}", e)),
            };
        }
    };

    // Debug: print OBJSENSE
    let diagnostics_enabled = std::env::var("MINIX_DIAGNOSTICS").is_ok();
    if diagnostics_enabled {
        let eq_count = qps.con_lower.iter().zip(qps.con_upper.iter())
            .filter(|(&l, &u)| (l - u).abs() < 1e-10 && l.is_finite())
            .count();
        eprintln!("[{}] obj_sense={} ({}) n={} m={} p_triplets={} equalities={}",
            name,
            qps.obj_sense,
            if qps.obj_sense < 0.0 { "MAX" } else { "MIN" },
            qps.n,
            qps.m,
            qps.p_triplets.len(),
            eq_count
        );
    }

    // Convert to conic form
    let prob = match qps.to_problem_data() {
        Ok(p) => p,
        Err(e) => {
            return BenchmarkResult {
                name: name.to_string(),
                n: qps.n,
                m: qps.m,
                status: SolveStatus::NumericalError,
                iterations: 0,
                obj_val: f64::NAN,
                mu: f64::NAN,
                solve_time_ms: 0.0,
                error: Some(format!("Conversion error: {}", e)),
            };
        }
    };

    // Solve
    let start = Instant::now();
    let result = solve_with_choice(&prob, settings, solver);
    let elapsed = start.elapsed();

    let diagnostics_enabled = std::env::var("MINIX_DIAGNOSTICS").is_ok();

    match result {
        Ok(res) => {
            if diagnostics_enabled || res.status != SolveStatus::Optimal {
                print_diagnostics(name, &prob, &res);
            }

            BenchmarkResult {
                name: name.to_string(),
                n: prob.num_vars(),
                m: prob.num_constraints(),
                status: res.status,
                iterations: res.info.iters,
                obj_val: res.obj_val,
                mu: res.info.mu,
                solve_time_ms: elapsed.as_secs_f64() * 1000.0,
                error: None,
            }
        }
        Err(e) => BenchmarkResult {
            name: name.to_string(),
            n: prob.num_vars(),
            m: prob.num_constraints(),
            status: SolveStatus::NumericalError,
            iterations: 0,
            obj_val: f64::NAN,
            mu: f64::NAN,
            solve_time_ms: elapsed.as_secs_f64() * 1000.0,
            error: Some(e.to_string()),
        },
    }
}

/// Run full Maros-Meszaros benchmark suite
pub fn run_full_suite(
    settings: &SolverSettings,
    max_problems: Option<usize>,
    solver: SolverChoice,
) -> Vec<BenchmarkResult> {
    let problems: Vec<&str> = MM_PROBLEMS
        .iter()
        .take(max_problems.unwrap_or(MM_PROBLEMS.len()))
        .copied()
        .collect();

    let mut results = Vec::with_capacity(problems.len());

    for (i, name) in problems.iter().enumerate() {
        eprint!("[{}/{}] {} ... ", i + 1, problems.len(), name);
        let result = run_single(name, settings, solver);

        let status_str = match result.status {
            SolveStatus::Optimal => "✓",
            SolveStatus::AlmostOptimal => "~",
            SolveStatus::MaxIters => "M",
            SolveStatus::NumericalError => "N",
            _ => "?",
        };

        if result.error.is_some() {
            eprintln!("ERROR");
        } else {
            eprintln!("{} ({} iters, {:.1}ms)", status_str, result.iterations, result.solve_time_ms);
        }

        results.push(result);
    }

    results
}

/// Compute summary statistics
pub fn compute_summary(results: &[BenchmarkResult]) -> BenchmarkSummary {
    let total = results.len();
    let mut optimal = 0;
    let mut almost_optimal = 0;
    let mut max_iters = 0;
    let mut numerical_errors = 0;
    let mut parse_errors = 0;
    let mut total_time_s = 0.0;
    let mut iter_log_sum = 0.0;
    let mut iter_count = 0;
    let mut time_log_sum = 0.0;
    let mut time_count = 0;

    for r in results {
        total_time_s += r.solve_time_ms / 1000.0;

        if r.error.is_some() && r.error.as_ref().unwrap().contains("Parse") {
            parse_errors += 1;
            continue;
        }

        match r.status {
            SolveStatus::Optimal => {
                optimal += 1;
                if r.iterations > 0 {
                    iter_log_sum += (r.iterations as f64).ln();
                    iter_count += 1;
                }
                // Shifted geometric mean for time (shift by 1.0 ms for robustness)
                if r.solve_time_ms > 0.0 {
                    time_log_sum += (r.solve_time_ms + 1.0).ln();
                    time_count += 1;
                }
            }
            SolveStatus::AlmostOptimal => {
                almost_optimal += 1;
                if r.iterations > 0 {
                    iter_log_sum += (r.iterations as f64).ln();
                    iter_count += 1;
                }
                if r.solve_time_ms > 0.0 {
                    time_log_sum += (r.solve_time_ms + 1.0).ln();
                    time_count += 1;
                }
            }
            SolveStatus::MaxIters => max_iters += 1,
            SolveStatus::NumericalError => numerical_errors += 1,
            _ => {}
        }
    }

    let geom_mean_iters = if iter_count > 0 {
        (iter_log_sum / iter_count as f64).exp()
    } else {
        0.0
    };

    // Shifted geometric mean: exp(mean(log(t + shift))) - shift
    let geom_mean_time_ms = if time_count > 0 {
        (time_log_sum / time_count as f64).exp() - 1.0
    } else {
        0.0
    };

    BenchmarkSummary {
        total,
        optimal,
        almost_optimal,
        max_iters,
        numerical_errors,
        parse_errors,
        total_time_s,
        geom_mean_iters,
        geom_mean_time_ms,
    }
}

/// Print results summary
pub fn print_summary(summary: &BenchmarkSummary) {
    println!("\n{}", "=".repeat(60));
    println!("Maros-Meszaros Benchmark Summary");
    println!("{}", "=".repeat(60));
    println!("Total problems:      {}", summary.total);
    println!("Optimal:             {} ({:.1}%)",
             summary.optimal,
             100.0 * summary.optimal as f64 / summary.total as f64);
    println!("AlmostOptimal:       {} ({:.1}%)",
             summary.almost_optimal,
             100.0 * summary.almost_optimal as f64 / summary.total as f64);
    let combined = summary.optimal + summary.almost_optimal;
    println!("Combined (Opt+Almost): {} ({:.1}%)",
             combined,
             100.0 * combined as f64 / summary.total as f64);
    println!("Max iterations:      {}", summary.max_iters);
    println!("Numerical errors:    {}", summary.numerical_errors);
    println!("Parse errors:        {}", summary.parse_errors);
    println!("Total time:          {:.2}s", summary.total_time_s);
    println!("Geom mean iters:     {:.1}", summary.geom_mean_iters);
    println!("Geom mean time:      {:.1}ms", summary.geom_mean_time_ms);
    println!("{}", "=".repeat(60));
}

/// Print detailed results table
pub fn print_results_table(results: &[BenchmarkResult]) {
    println!("\n{:<15} {:>6} {:>8} {:>8} {:>10} {:>12} {:>10}",
             "Problem", "n", "m", "Status", "Iters", "Obj", "Time(ms)");
    println!("{}", "-".repeat(75));

    for r in results {
        let status_str = match r.status {
            SolveStatus::Optimal => "Optimal",
            SolveStatus::AlmostOptimal => "AlmostOpt",
            SolveStatus::MaxIters => "MaxIter",
            SolveStatus::NumericalError => "NumErr",
            SolveStatus::PrimalInfeasible => "PrimInf",
            SolveStatus::DualInfeasible => "DualInf",
            _ => "Other",
        };

        if r.error.is_some() {
            println!("{:<15} {:>6} {:>8} {:>8} {:>10} {:>12} {:>10}",
                     r.name, "-", "-", "Error", "-", "-", "-");
        } else {
            println!("{:<15} {:>6} {:>8} {:>8} {:>10} {:>12.4e} {:>10.1}",
                     r.name, r.n, r.m, status_str, r.iterations, r.obj_val, r.solve_time_ms);
        }
    }
}

=== src/qps.rs ===
//! QPS file format parser for quadratic programming problems.
//!
//! QPS is an extension of MPS format that adds quadratic objective terms.
//! Format specification based on CPLEX and standard conventions.
//!
//! Sections:
//! - NAME: problem name
//! - ROWS: constraint definitions (N=objective, E/L/G=equality/less/greater)
//! - COLUMNS: A matrix coefficients
//! - RHS: right-hand side vector b
//! - RANGES: range constraints (optional)
//! - BOUNDS: variable bounds (optional)
//! - QUADOBJ/QMATRIX: quadratic objective terms (optional)
//! - ENDATA: end marker

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

use anyhow::{anyhow, Context, Result};
use solver_core::linalg::sparse;
use solver_core::{ConeSpec, ProblemData};

/// Parsed QPS problem data (before conversion to conic form).
#[derive(Debug, Clone)]
pub struct QpsProblem {
    /// Problem name
    pub name: String,
    /// Number of variables
    pub n: usize,
    /// Number of constraints (excluding objective)
    pub m: usize,
    /// Objective sense (1 = minimize, -1 = maximize)
    pub obj_sense: f64,
    /// Linear cost vector q (length n)
    pub q: Vec<f64>,
    /// Quadratic cost matrix P (n x n, upper triangle triplets)
    pub p_triplets: Vec<(usize, usize, f64)>,
    /// Constraint matrix A (m x n, triplets)
    pub a_triplets: Vec<(usize, usize, f64)>,
    /// Constraint lower bounds (length m)
    pub con_lower: Vec<f64>,
    /// Constraint upper bounds (length m)
    pub con_upper: Vec<f64>,
    /// Variable lower bounds (length n)
    pub var_lower: Vec<f64>,
    /// Variable upper bounds (length n)
    pub var_upper: Vec<f64>,
    /// Variable names
    pub var_names: Vec<String>,
    /// Constraint names
    pub con_names: Vec<String>,
}

impl QpsProblem {
    /// Convert to conic ProblemData format.
    ///
    /// Transforms the QP into standard conic form:
    /// - Equality constraints: A_eq x + s_eq = b_eq, s_eq in Zero cone
    /// - Inequality constraints: converted to slack form with NonNeg cone
    /// - Variable bounds: converted to inequality constraints
    pub fn to_problem_data(&self) -> Result<ProblemData> {
        // Count constraint types
        let mut n_eq = 0;
        let mut n_ineq = 0;

        for i in 0..self.m {
            let lb = self.con_lower[i];
            let ub = self.con_upper[i];

            if lb == ub && lb.is_finite() {
                n_eq += 1;
            } else {
                // Range or one-sided inequality
                if lb.is_finite() && lb > f64::NEG_INFINITY {
                    n_ineq += 1; // a'x >= lb
                }
                if ub.is_finite() && ub < f64::INFINITY {
                    n_ineq += 1; // a'x <= ub
                }
            }
        }

        // Count variable bound constraints
        let mut n_var_bounds = 0;
        for j in 0..self.n {
            if self.var_lower[j] > f64::NEG_INFINITY && self.var_lower[j] != 0.0 {
                n_var_bounds += 1;
            } else if self.var_lower[j] == 0.0 {
                n_var_bounds += 1; // x >= 0
            }
            if self.var_upper[j] < f64::INFINITY {
                n_var_bounds += 1;
            }
        }

        let total_constraints = n_eq + n_ineq + n_var_bounds;

        // Build constraint matrix and RHS
        let mut triplets = Vec::new();
        let mut b = Vec::with_capacity(total_constraints);
        let mut row = 0;
        let mut row_entries: Vec<Vec<(usize, f64)>> = vec![Vec::new(); self.m];
        for &(r, c, v) in &self.a_triplets {
            row_entries[r].push((c, v));
        }

        // 1. Equality constraints (Zero cone)
        for i in 0..self.m {
            let lb = self.con_lower[i];
            let ub = self.con_upper[i];

            if lb == ub && lb.is_finite() {
                // Equality: Ax = b
                for &(c, v) in &row_entries[i] {
                    triplets.push((row, c, v));
                }
                b.push(lb);
                row += 1;
            }
        }
        let _eq_end = row;

        // 2. Inequality constraints (NonNeg cone)
        // Format: Ax + s = b, s >= 0
        // For a'x <= u: a'x + s = u, s >= 0
        // For a'x >= l: -a'x + s = -l, s >= 0
        for i in 0..self.m {
            let lb = self.con_lower[i];
            let ub = self.con_upper[i];

            if lb == ub && lb.is_finite() {
                continue; // Already handled as equality
            }

            // Upper bound: a'x <= ub
            if ub.is_finite() && ub < f64::INFINITY {
                for &(c, v) in &row_entries[i] {
                    triplets.push((row, c, v));
                }
                b.push(ub);
                row += 1;
            }

            // Lower bound: a'x >= lb => -a'x <= -lb
            if lb.is_finite() && lb > f64::NEG_INFINITY {
                for &(c, v) in &row_entries[i] {
                    triplets.push((row, c, -v));
                }
                b.push(-lb);
                row += 1;
            }
        }

        // 3. Variable bounds (NonNeg cone)
        // x_j >= l: -x_j + s = -l, s >= 0
        // x_j <= u: x_j + s = u, s >= 0
        for j in 0..self.n {
            let lb = self.var_lower[j];
            let ub = self.var_upper[j];

            // Lower bound
            if lb > f64::NEG_INFINITY {
                triplets.push((row, j, -1.0));
                b.push(-lb);
                row += 1;
            }

            // Upper bound
            if ub < f64::INFINITY {
                triplets.push((row, j, 1.0));
                b.push(ub);
                row += 1;
            }
        }

        assert_eq!(row, total_constraints);

        // Build sparse matrices
        let a = sparse::from_triplets(total_constraints, self.n, triplets);

        // Scale objective by sense.
        //
        // Note: For quadratic objectives, the QP form is (1/2) x'P x + q'x.
        // Converting MAX to MIN requires negating *both* q and P.
        let p = if self.p_triplets.is_empty() {
            None
        } else {
            let p_triplets: Vec<(usize, usize, f64)> = self
                .p_triplets
                .iter()
                .map(|&(i, j, v)| (i, j, v * self.obj_sense))
                .collect();
            Some(sparse::from_triplets(self.n, self.n, p_triplets))
        };

        let q: Vec<f64> = self.q.iter().map(|&v| v * self.obj_sense).collect();

        // Build cone specification
        let mut cones = Vec::new();
        if n_eq > 0 {
            cones.push(ConeSpec::Zero { dim: n_eq });
        }
        let ineq_total = n_ineq + n_var_bounds;
        if ineq_total > 0 {
            cones.push(ConeSpec::NonNeg { dim: ineq_total });
        }

        Ok(ProblemData {
            P: p,
            q,
            A: a,
            b,
            cones,
            var_bounds: None,
            integrality: None,
        })
    }

    /// Convert to SOCP form (no P matrix, quadratic term as rotated SOC constraint).
    ///
    /// Transforms QP: min (1/2) x'Px + q'x s.t. Ax + s = b, s ∈ K
    /// Into SOCP:     min t + q'x s.t. Ax + s = b, s ∈ K, (t, 1/2, Lx) ∈ RSOC
    ///
    /// where P = L'L (Cholesky factorization) and RSOC means 2*t*(1/2) >= ||Lx||²
    ///
    /// The rotated SOC (RSOC) is converted to standard SOC via:
    /// (u, v, w) ∈ RSOC iff ((u+v)/√2, (u-v)/√2, w) ∈ SOC
    ///
    /// This is the form CVXPY sends to conic solvers.
    pub fn to_socp_form(&self) -> Result<ProblemData> {
        // First build the standard QP form to get constraints
        let qp = self.to_problem_data()?;

        // If no quadratic term, this is already an LP - just return it without P
        if self.p_triplets.is_empty() {
            return Ok(ProblemData {
                P: None,
                q: qp.q,
                A: qp.A,
                b: qp.b,
                cones: qp.cones,
                var_bounds: None,
                integrality: None,
            });
        }

        let n = self.n;
        let m_orig = qp.A.rows();

        // Build P matrix and compute Cholesky factorization P = L'L
        // Use dense Cholesky for simplicity
        let p_triplets: Vec<(usize, usize, f64)> = self
            .p_triplets
            .iter()
            .map(|&(i, j, v)| (i, j, v * self.obj_sense))
            .collect();

        let mut p_dense = vec![0.0; n * n];
        for &(i, j, v) in &p_triplets {
            p_dense[i * n + j] += v;
            if i != j {
                p_dense[j * n + i] += v;
            }
        }

        // Compute Cholesky L such that P = L'L using simple implementation
        // For P that's only positive semidefinite (some zero eigenvalues), we handle
        // small/negative pivots by skipping those rows (they don't contribute to ||Lx||)
        let mut l = vec![0.0; n * n];
        let mut valid_rows = Vec::new();
        for i in 0..n {
            for j in 0..=i {
                let mut sum = p_dense[i * n + j];
                for k in 0..j {
                    sum -= l[i * n + k] * l[j * n + k];
                }
                if i == j {
                    if sum > 1e-12 {
                        l[i * n + j] = sum.sqrt();
                        valid_rows.push(i);
                    } else {
                        // Zero or negative pivot - this row of L will be zero
                        l[i * n + j] = 0.0;
                    }
                } else if l[j * n + j].abs() > 1e-14 {
                    l[i * n + j] = sum / l[j * n + j];
                } else {
                    l[i * n + j] = 0.0;
                }
            }
        }

        // Count non-zero rows in L (for SOC dimension)
        let mut nonzero_rows = Vec::new();
        for i in 0..n {
            let row_norm_sq: f64 = (0..=i).map(|j| l[i * n + j] * l[i * n + j]).sum();
            if row_norm_sq > 1e-12 {
                nonzero_rows.push(i);
            }
        }

        if nonzero_rows.is_empty() {
            // P is zero matrix - just an LP
            return Ok(ProblemData {
                P: None,
                q: qp.q,
                A: qp.A,
                b: qp.b,
                cones: qp.cones,
                var_bounds: None,
                integrality: None,
            });
        }

        // For QP objective (1/2) x'Px + q'x, we use rotated SOC:
        // min t + q'x s.t. (t, v, Lx) ∈ RSOC, meaning 2*t*v >= ||Lx||²
        //
        // We want t >= ||Lx||²/2, so we need 2tv >= ||Lx||² with t >= ||Lx||²/(2v).
        // Setting v = 1 gives t >= ||Lx||²/2 as required.
        //
        // Convert RSOC to SOC: (u, v, w) ∈ RSOC iff ((u+v)/√2, (u-v)/√2, w) ∈ SOC
        // With u = t, v = 1, we get: ((t + 1)/√2, (t - 1)/√2, Lx) ∈ SOC
        //
        // We embed the constant 1 directly in the b vector (no auxiliary variable):
        // Row for soc[0]: -t/√2 + slack[0] = 1/√2  =>  slack[0] = (t+1)/√2
        // Row for soc[1]: -t/√2 + slack[1] = -1/√2 =>  slack[1] = (t-1)/√2
        // Rows for soc[2+k]: -L[k,:]*x + slack[2+k] = 0

        let sqrt2 = std::f64::consts::SQRT_2;
        let soc_dim = 2 + nonzero_rows.len(); // (t+1)/√2, (t-1)/√2, Lx...

        // New problem has n+1 variables: [x (n), t (1)]
        let new_n = n + 1;
        let new_m = m_orig + soc_dim; // original + SOC

        // Build new A matrix
        let mut new_triplets = Vec::new();

        // Copy original constraints (only affecting x, columns 0..n)
        for (&val, (row, col)) in qp.A.iter() {
            new_triplets.push((row, col, val));
        }

        // SOC constraint: ((t+1)/√2, (t-1)/√2, Lx) in SOC
        let soc_start = m_orig;

        // slack[0] = (t+1)/√2:  -t/√2 + slack[0] = 1/√2
        new_triplets.push((soc_start, n, -1.0 / sqrt2)); // -t/√2

        // slack[1] = (t-1)/√2:  -t/√2 + slack[1] = -1/√2
        new_triplets.push((soc_start + 1, n, -1.0 / sqrt2)); // -t/√2

        // Remaining rows: -L[i,:]*x + slack[2+k] = 0
        for (idx, &row_i) in nonzero_rows.iter().enumerate() {
            for j in 0..=row_i {
                let val = l[row_i * n + j];
                if val.abs() > 1e-14 {
                    new_triplets.push((soc_start + 2 + idx, j, -val));
                }
            }
        }

        let new_a = sparse::from_triplets(new_m, new_n, new_triplets);

        // Build new b vector
        let mut new_b = qp.b.clone();
        // SOC rows: b = [1/√2, -1/√2, 0, 0, ...]
        new_b.push(1.0 / sqrt2);  // for (t+1)/√2
        new_b.push(-1.0 / sqrt2); // for (t-1)/√2
        new_b.extend(vec![0.0; nonzero_rows.len()]); // for Lx

        // Build new q vector: [original q, 1.0 for t]
        let mut new_q = qp.q.clone();
        new_q.push(1.0); // coefficient for t in objective

        // Build cone specification
        let mut new_cones = qp.cones.clone();
        new_cones.push(ConeSpec::Soc { dim: soc_dim });

        Ok(ProblemData {
            P: None, // No quadratic term - absorbed into rotated SOC
            q: new_q,
            A: new_a,
            b: new_b,
            cones: new_cones,
            var_bounds: None,
            integrality: None,
        })
    }
}

/// Parse a QPS file.
pub fn parse_qps<P: AsRef<Path>>(path: P) -> Result<QpsProblem> {
    let file = File::open(path.as_ref())
        .with_context(|| format!("Failed to open QPS file: {:?}", path.as_ref()))?;
    let reader = BufReader::new(file);

    let mut name = String::new();
    let mut obj_row: Option<String> = None;
    let mut row_types: HashMap<String, char> = HashMap::new();
    let mut row_order: Vec<String> = Vec::new();
    let mut var_map: HashMap<String, usize> = HashMap::new();
    let mut var_names: Vec<String> = Vec::new();
    let mut con_map: HashMap<String, usize> = HashMap::new();
    let mut con_names: Vec<String> = Vec::new();

    let mut a_triplets: Vec<(usize, usize, f64)> = Vec::new();
    let mut q_coeffs: HashMap<String, f64> = HashMap::new();
    let mut p_triplets: Vec<(usize, usize, f64)> = Vec::new();

    let mut rhs: HashMap<String, f64> = HashMap::new();
    let mut ranges: HashMap<String, f64> = HashMap::new();
    let mut var_lower: HashMap<String, f64> = HashMap::new();
    let mut var_upper: HashMap<String, f64> = HashMap::new();

    let mut section = String::new();
    let mut obj_sense = 1.0; // 1 = minimize, -1 = maximize

    for line_result in reader.lines() {
        let line_raw = line_result?;
        let line = line_raw.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('*') {
            continue;
        }

        // Check for section headers (use trimmed line)
        if line.starts_with("NAME") {
            name = line.split_whitespace().nth(1).unwrap_or("unknown").to_string();
            section = "NAME".to_string();
            continue;
        } else if line == "ROWS" {
            section = "ROWS".to_string();
            continue;
        } else if line == "COLUMNS" {
            section = "COLUMNS".to_string();
            continue;
        } else if line == "RHS" {
            section = "RHS".to_string();
            continue;
        } else if line == "RANGES" {
            section = "RANGES".to_string();
            continue;
        } else if line == "BOUNDS" {
            section = "BOUNDS".to_string();
            continue;
        } else if line == "QUADOBJ" || line == "QMATRIX" || line == "QSECTION" {
            section = "QUADOBJ".to_string();
            continue;
        } else if line == "ENDATA" {
            break;
        } else if line.starts_with("OBJSENSE") {
            section = "OBJSENSE".to_string();
            continue;
        }

        // Parse section content
        match section.as_str() {
            "OBJSENSE" => {
                // Handle OBJSENSE MAX or MIN
                if line.contains("MAX") {
                    obj_sense = -1.0;
                }
            }
            "ROWS" => {
                // MPS format: type at columns 2-3 (1-indexed), name at columns 5-12
                // Some files put type at position 1, others at position 2 (0-indexed)
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // Find row type - look for N/E/L/G at position 1 or 2
                let rtype = if line_len >= 3 {
                    let c1 = line_bytes[1] as char;
                    let c2 = line_bytes[2] as char;
                    if matches!(c1, 'N' | 'E' | 'L' | 'G') {
                        c1
                    } else if matches!(c2, 'N' | 'E' | 'L' | 'G') {
                        c2
                    } else {
                        continue;
                    }
                } else if line_len >= 2 {
                    line_bytes[1] as char
                } else {
                    continue;
                };

                // Extract row name (columns 5-12, 0-indexed 4-11)
                let rname = if line_len >= 12 {
                    String::from_utf8_lossy(&line_bytes[4..12]).trim().to_string()
                } else if line_len > 4 {
                    String::from_utf8_lossy(&line_bytes[4..]).trim().to_string()
                } else {
                    continue;
                };

                if rname.is_empty() {
                    continue;
                }

                if rtype == 'N' {
                    // Objective row
                    if obj_row.is_none() {
                        obj_row = Some(rname.clone());
                    }
                } else {
                    // Constraint row
                    let idx = con_names.len();
                    con_map.insert(rname.clone(), idx);
                    con_names.push(rname.clone());
                }
                row_types.insert(rname.clone(), rtype);
                row_order.push(rname);
            }
            "COLUMNS" => {
                // MPS fixed-width format: fields at columns 5-12, 15-22, 25-36, 40-47, 50-61
                // (0-indexed: 4-11, 14-21, 24-35, 39-46, 49-60)
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // Extract variable name (columns 5-12, 0-indexed 4-11)
                let var_name = if line_len >= 12 {
                    String::from_utf8_lossy(&line_bytes[4..12]).trim().to_string()
                } else if line_len > 4 {
                    String::from_utf8_lossy(&line_bytes[4..]).trim().to_string()
                } else {
                    continue;
                };

                if var_name.is_empty() {
                    continue;
                }

                // Get or create variable index
                let var_idx = *var_map.entry(var_name.clone()).or_insert_with(|| {
                    let idx = var_names.len();
                    var_names.push(var_name.clone());
                    idx
                });

                // Parse first (row_name, value) pair at columns 15-22, 25-36
                if line_len >= 25 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[14..22.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 36 {
                        String::from_utf8_lossy(&line_bytes[24..36]).trim().to_string()
                    } else if line_len > 24 {
                        String::from_utf8_lossy(&line_bytes[24..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);

                        if Some(row_name.clone()) == obj_row {
                            q_coeffs.insert(var_name.clone(), value);
                        } else if let Some(&con_idx) = con_map.get(&row_name) {
                            a_triplets.push((con_idx, var_idx, value));
                        }
                    }
                }

                // Parse second (row_name, value) pair at columns 40-47, 50-61
                if line_len >= 50 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[39..47.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 61 {
                        String::from_utf8_lossy(&line_bytes[49..61]).trim().to_string()
                    } else if line_len > 49 {
                        String::from_utf8_lossy(&line_bytes[49..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);

                        if Some(row_name.clone()) == obj_row {
                            q_coeffs.insert(var_name.clone(), value);
                        } else if let Some(&con_idx) = con_map.get(&row_name) {
                            a_triplets.push((con_idx, var_idx, value));
                        }
                    }
                }
            }
            "RHS" => {
                // MPS fixed-width format: RHS name at columns 5-12, then pairs at 15-22/25-36 and 40-47/50-61
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // First pair: row name at columns 15-22, value at 25-36
                if line_len >= 25 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[14..22.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 36 {
                        String::from_utf8_lossy(&line_bytes[24..36]).trim().to_string()
                    } else if line_len > 24 {
                        String::from_utf8_lossy(&line_bytes[24..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);
                        rhs.insert(row_name, value);
                    }
                }

                // Second pair: row name at columns 40-47, value at 50-61
                if line_len >= 50 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[39..47.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 61 {
                        String::from_utf8_lossy(&line_bytes[49..61]).trim().to_string()
                    } else if line_len > 49 {
                        String::from_utf8_lossy(&line_bytes[49..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);
                        rhs.insert(row_name, value);
                    }
                }
            }
            "RANGES" => {
                // MPS fixed-width format: same as RHS
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // First pair: row name at columns 15-22, value at 25-36
                if line_len >= 25 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[14..22.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 36 {
                        String::from_utf8_lossy(&line_bytes[24..36]).trim().to_string()
                    } else if line_len > 24 {
                        String::from_utf8_lossy(&line_bytes[24..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);
                        ranges.insert(row_name, value.abs());
                    }
                }

                // Second pair: row name at columns 40-47, value at 50-61
                if line_len >= 50 {
                    let row_name = String::from_utf8_lossy(
                        &line_bytes[39..47.min(line_len)]
                    ).trim().to_string();
                    let value_str = if line_len >= 61 {
                        String::from_utf8_lossy(&line_bytes[49..61]).trim().to_string()
                    } else if line_len > 49 {
                        String::from_utf8_lossy(&line_bytes[49..]).trim().to_string()
                    } else {
                        String::new()
                    };

                    if !row_name.is_empty() && !value_str.is_empty() {
                        let value: f64 = value_str.parse().unwrap_or(0.0);
                        ranges.insert(row_name, value.abs());
                    }
                }
            }
            "BOUNDS" => {
                // MPS fixed-width format: type at columns 2-3, bound name at 5-12, var name at 15-22, value at 25-36
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // Extract bound type (columns 2-3, 0-indexed 1-2)
                let btype = if line_len >= 3 {
                    String::from_utf8_lossy(&line_bytes[1..3]).trim().to_string()
                } else {
                    continue;
                };

                // Extract variable name (columns 15-22, 0-indexed 14-21)
                let var_name = if line_len >= 22 {
                    String::from_utf8_lossy(&line_bytes[14..22]).trim().to_string()
                } else if line_len > 14 {
                    String::from_utf8_lossy(&line_bytes[14..]).trim().to_string()
                } else {
                    continue;
                };

                if var_name.is_empty() {
                    continue;
                }

                // Extract value (columns 25-36, 0-indexed 24-35)
                let value: f64 = if line_len >= 25 {
                    let value_str = if line_len >= 36 {
                        String::from_utf8_lossy(&line_bytes[24..36]).trim().to_string()
                    } else {
                        String::from_utf8_lossy(&line_bytes[24..]).trim().to_string()
                    };
                    value_str.parse().unwrap_or(0.0)
                } else {
                    0.0
                };

                match btype.as_str() {
                    "LO" => {
                        var_lower.insert(var_name, value);
                    }
                    "UP" => {
                        var_upper.insert(var_name, value);
                    }
                    "FX" => {
                        var_lower.insert(var_name.clone(), value);
                        var_upper.insert(var_name, value);
                    }
                    "FR" => {
                        var_lower.insert(var_name.clone(), f64::NEG_INFINITY);
                        var_upper.insert(var_name, f64::INFINITY);
                    }
                    "MI" => {
                        var_lower.insert(var_name, f64::NEG_INFINITY);
                    }
                    "PL" => {
                        var_upper.insert(var_name, f64::INFINITY);
                    }
                    "BV" => {
                        // Binary variable
                        var_lower.insert(var_name.clone(), 0.0);
                        var_upper.insert(var_name, 1.0);
                    }
                    _ => {}
                }
            }
            "QUADOBJ" => {
                // MPS fixed-width format for QUADOBJ: var1 at 5-12, var2 at 15-22, value at 25-36
                let line_bytes = line_raw.as_bytes();
                let line_len = line_bytes.len();

                // Extract var1 (columns 5-12, 0-indexed 4-11)
                let var1 = if line_len >= 12 {
                    String::from_utf8_lossy(&line_bytes[4..12]).trim().to_string()
                } else if line_len > 4 {
                    String::from_utf8_lossy(&line_bytes[4..]).trim().to_string()
                } else {
                    continue;
                };

                // Extract var2 (columns 15-22, 0-indexed 14-21)
                let var2 = if line_len >= 22 {
                    String::from_utf8_lossy(&line_bytes[14..22]).trim().to_string()
                } else if line_len > 14 {
                    String::from_utf8_lossy(&line_bytes[14..]).trim().to_string()
                } else {
                    continue;
                };

                // Extract value (columns 25-36, 0-indexed 24-35)
                let value: f64 = if line_len >= 25 {
                    let value_str = if line_len >= 36 {
                        String::from_utf8_lossy(&line_bytes[24..36]).trim().to_string()
                    } else {
                        String::from_utf8_lossy(&line_bytes[24..]).trim().to_string()
                    };
                    value_str.parse().unwrap_or(0.0)
                } else {
                    continue;
                };

                if let (Some(&i), Some(&j)) = (var_map.get(&var1), var_map.get(&var2)) {
                    // Store upper triangle only
                    let (row, col) = if i <= j { (i, j) } else { (j, i) };
                    // QPS stores Q such that obj = 0.5 x'Qx, so we use value directly
                    p_triplets.push((row, col, value));
                }
            }
            _ => {}
        }
    }

    let n = var_names.len();
    let m = con_names.len();

    if n == 0 {
        return Err(anyhow!("No variables found in QPS file"));
    }

    // Build vectors
    let q: Vec<f64> = var_names
        .iter()
        .map(|name| *q_coeffs.get(name).unwrap_or(&0.0))
        .collect();

    // Build constraint bounds based on row types
    let mut con_lower = vec![f64::NEG_INFINITY; m];
    let mut con_upper = vec![f64::INFINITY; m];

    for (name, &idx) in &con_map {
        let rtype = row_types.get(name).copied().unwrap_or('E');
        let rhs_val = rhs.get(name).copied().unwrap_or(0.0);
        let range_val = ranges.get(name).copied().unwrap_or(0.0);

        match rtype {
            'E' => {
                // Equality
                con_lower[idx] = rhs_val;
                con_upper[idx] = rhs_val;
            }
            'L' => {
                // Less than or equal
                con_upper[idx] = rhs_val;
                if range_val > 0.0 {
                    con_lower[idx] = rhs_val - range_val;
                }
            }
            'G' => {
                // Greater than or equal
                con_lower[idx] = rhs_val;
                if range_val > 0.0 {
                    con_upper[idx] = rhs_val + range_val;
                }
            }
            _ => {}
        }
    }

    // Build variable bounds (default: x >= 0)
    let var_lower_vec: Vec<f64> = var_names
        .iter()
        .map(|name| var_lower.get(name).copied().unwrap_or(0.0))
        .collect();

    let var_upper_vec: Vec<f64> = var_names
        .iter()
        .map(|name| var_upper.get(name).copied().unwrap_or(f64::INFINITY))
        .collect();

    Ok(QpsProblem {
        name,
        n,
        m,
        obj_sense, // Parsed from OBJSENSE section (1.0 = min, -1.0 = max)
        q,
        p_triplets,
        a_triplets,
        con_lower,
        con_upper,
        var_lower: var_lower_vec,
        var_upper: var_upper_vec,
        var_names,
        con_names,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_simple_qp_conversion() {
        // Create a simple QP manually
        let qps = QpsProblem {
            name: "test".to_string(),
            n: 2,
            m: 1,
            obj_sense: 1.0,
            q: vec![1.0, 1.0],
            p_triplets: vec![(0, 0, 2.0), (1, 1, 2.0)], // P = 2I
            a_triplets: vec![(0, 0, 1.0), (0, 1, 1.0)], // x1 + x2 = 1
            con_lower: vec![1.0],
            con_upper: vec![1.0],
            var_lower: vec![0.0, 0.0],
            var_upper: vec![f64::INFINITY, f64::INFINITY],
            var_names: vec!["x1".to_string(), "x2".to_string()],
            con_names: vec!["c1".to_string()],
        };

        let prob = qps.to_problem_data().unwrap();

        assert_eq!(prob.num_vars(), 2);
        assert!(prob.P.is_some());
        assert_eq!(prob.q.len(), 2);
    }

    fn write_temp_qps(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().expect("Failed to create temp file");
        file.write_all(content.as_bytes()).expect("Failed to write temp file");
        file.flush().expect("Failed to flush temp file");
        file
    }

    #[test]
    fn test_fixed_width_parsing_with_spaces_in_names() {
        // Test that variable names with internal spaces are parsed correctly
        // using fixed-width column format (MPS standard).
        // This was the root cause of the QFORPLAN bug where "DEDO3 11" was
        // incorrectly split into two tokens.
        let qps_content = r#"NAME          TESTPROB
ROWS
 N  COST
 E  ROW1
COLUMNS
    VAR 1     COST                 1.0   ROW1                 1.0
    VAR 2     COST                 2.0   ROW1                 1.0
RHS
    RHS1      ROW1                 5.0
BOUNDS
 UP BOUND1    VAR 1                10.0
 UP BOUND1    VAR 2                10.0
ENDATA
"#;
        let temp_file = write_temp_qps(qps_content);
        let qps = parse_qps(temp_file.path()).expect("Should parse QPS with spaced names");

        // Should have 2 variables, not more (if split_whitespace was used, "VAR" and "1"
        // would be separate, causing wrong variable count)
        assert_eq!(qps.n, 2, "Expected 2 variables");
        assert_eq!(qps.var_names.len(), 2);
        assert!(qps.var_names.contains(&"VAR 1".to_string()),
            "Variable name 'VAR 1' should be preserved with space");
        assert!(qps.var_names.contains(&"VAR 2".to_string()),
            "Variable name 'VAR 2' should be preserved with space");
    }

    #[test]
    fn test_fixed_width_row_type_position() {
        // Test that row type can be at position 1 or 2 (different files use different positions)
        // Position 1: " N  COST" (type at index 1)
        // Position 2: "  N COST" (type at index 2)
        let qps_pos1 = r#"NAME          TEST1
ROWS
 N  OBJ
 E  CON1
COLUMNS
    X1        OBJ                  1.0   CON1                 1.0
RHS
    RHS1      CON1                 1.0
ENDATA
"#;
        let qps_pos2 = r#"NAME          TEST2
ROWS
  N OBJ
  E CON1
COLUMNS
    X1        OBJ                  1.0   CON1                 1.0
RHS
    RHS1      CON1                 1.0
ENDATA
"#;

        let temp1 = write_temp_qps(qps_pos1);
        let temp2 = write_temp_qps(qps_pos2);
        let result1 = parse_qps(temp1.path()).expect("Position 1 format");
        let result2 = parse_qps(temp2.path()).expect("Position 2 format");

        assert_eq!(result1.n, 1, "Position 1: expected 1 variable");
        assert_eq!(result1.m, 1, "Position 1: expected 1 constraint");
        assert_eq!(result2.n, 1, "Position 2: expected 1 variable");
        assert_eq!(result2.m, 1, "Position 2: expected 1 constraint");
    }
}

=== src/regression.rs ===
use solver_core::ipm2::metrics::compute_unscaled_metrics;
use solver_core::{ConeSpec, ProblemData, SolveStatus, SolverSettings};
use serde::{Deserialize, Serialize};

use crate::maros_meszaros::{load_local_problem, mm_problem_names};
use crate::sdplib;
use crate::solver_choice::{solve_with_choice, SolverChoice};
use crate::test_problems;

pub struct RegressionResult {
    pub name: String,
    pub status: SolveStatus,
    pub rel_p: f64,
    pub rel_d: f64,
    pub gap_rel: f64,
    pub iterations: usize,
    pub expected_iters: Option<usize>,
    pub expected_status: Option<SolveStatus>,
    pub error: Option<String>,
    pub skipped: bool,
    pub expected_to_fail: bool,
    pub solve_time_ms: Option<u64>,
    pub kkt_factor_time_ms: Option<u64>,
    pub kkt_solve_time_ms: Option<u64>,
    pub cone_time_ms: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerfSummary {
    pub total_solve_ms: u64,
    pub total_kkt_factor_ms: u64,
    pub total_kkt_solve_ms: u64,
    pub total_cone_ms: u64,
    pub cases: usize,
}

impl PerfSummary {
    fn empty() -> Self {
        Self {
            total_solve_ms: 0,
            total_kkt_factor_ms: 0,
            total_kkt_solve_ms: 0,
            total_cone_ms: 0,
            cases: 0,
        }
    }
}

pub fn perf_summary(results: &[RegressionResult]) -> PerfSummary {
    let mut summary = PerfSummary::empty();
    for res in results {
        let (solve_ms, kkt_factor_ms, kkt_solve_ms, cone_ms) = match (
            res.solve_time_ms,
            res.kkt_factor_time_ms,
            res.kkt_solve_time_ms,
            res.cone_time_ms,
        ) {
            (Some(a), Some(b), Some(c), Some(d)) => (a, b, c, d),
            _ => continue,
        };

        summary.total_solve_ms += solve_ms;
        summary.total_kkt_factor_ms += kkt_factor_ms;
        summary.total_kkt_solve_ms += kkt_solve_ms;
        summary.total_cone_ms += cone_ms;
        summary.cases += 1;
    }
    summary
}

pub fn compare_perf_baseline(
    baseline: &PerfSummary,
    current: &PerfSummary,
    max_regression: f64,
) -> Vec<String> {
    let mut failures = Vec::new();
    let guard = |name: &str, base: u64, cur: u64| {
        if base == 0 {
            return None;
        }
        let ratio = cur as f64 / base as f64;
        if ratio > 1.0 + max_regression {
            Some(format!(
                "{} regression {:.2}x (baseline {}ms, current {}ms)",
                name, ratio, base, cur
            ))
        } else {
            None
        }
    };

    if let Some(msg) = guard(
        "solve_time",
        baseline.total_solve_ms,
        current.total_solve_ms,
    ) {
        failures.push(msg);
    }
    if let Some(msg) = guard(
        "kkt_factor_time",
        baseline.total_kkt_factor_ms,
        current.total_kkt_factor_ms,
    ) {
        failures.push(msg);
    }
    if let Some(msg) = guard(
        "kkt_solve_time",
        baseline.total_kkt_solve_ms,
        current.total_kkt_solve_ms,
    ) {
        failures.push(msg);
    }
    if let Some(msg) = guard(
        "cone_time",
        baseline.total_cone_ms,
        current.total_cone_ms,
    ) {
        failures.push(msg);
    }

    failures
}

/// Returns expected behavior for specific problems.
/// Used to track known expected statuses (e.g., NumericalLimit for BOYD-class problems)
/// and expected iteration counts for regression detection.
fn expected_behavior(name: &str) -> (Option<SolveStatus>, Option<usize>) {
    match name {
        // BOYD-class problems hit numerical precision floor (135,000x cancellation)
        // κ(K) > 1e13, rel_d stuck at ~1e-3 despite primal+gap converging
        "BOYD1" => (Some(SolveStatus::NumericalLimit), Some(50)),
        "BOYD2" => (Some(SolveStatus::NumericalLimit), Some(50)),

        // Add more specific expected behaviors here as needed
        // For most problems: (None, None) means expect Optimal with variable iterations
        _ => (None, None),
    }
}

pub fn run_regression_suite(
    settings: &SolverSettings,
    solver: SolverChoice,
    require_cache: bool,
    max_iter_fail: usize,
    socp_only: bool,
    filter: Option<&str>,
) -> Vec<RegressionResult> {
    let mut results = Vec::new();

    // Skip QP/SDP tests if socp_only is set
    if socp_only {
        return run_socp_tests(settings, solver, require_cache, filter);
    }

    // 108 Maros-Meszaros problems that truly meet quality standards (79.4% of 136)
    // Excluded: 28 problems with dual divergence or gap issues
    let qps_cases = [
        // HS problems (tiny)
        "HS21", "HS35", "HS35MOD", "HS51", "HS52", "HS53", "HS76", "HS118", "HS268",
        // Other tiny (<1ms)
        "TAME", "S268", "ZECEVIC2", "LOTSCHD", "QAFIRO",
        // CVXQP family (all 9)
        "CVXQP1_S", "CVXQP2_S", "CVXQP3_S",
        "CVXQP1_M", "CVXQP2_M", "CVXQP3_M",
        "CVXQP1_L", "CVXQP2_L", "CVXQP3_L",
        // DUAL/PRIMAL families (all 16)
        "DUAL1", "DUAL2", "DUAL3", "DUAL4",
        "DUALC1", "DUALC2", "DUALC5", "DUALC8",
        "PRIMAL1", "PRIMAL2", "PRIMAL3", "PRIMAL4",
        "PRIMALC1", "PRIMALC2", "PRIMALC5", "PRIMALC8",
        // AUG family (all 8)
        "AUG2D", "AUG2DC", "AUG2DCQP", "AUG2DQP",
        "AUG3D", "AUG3DC", "AUG3DCQP", "AUG3DQP",
        // CONT family (all 6)
        "CONT-050", "CONT-100", "CONT-101", "CONT-200", "CONT-201", "CONT-300",
        // LISWET family (all 12)
        "LISWET1", "LISWET2", "LISWET3", "LISWET4", "LISWET5", "LISWET6",
        "LISWET7", "LISWET8", "LISWET9", "LISWET10", "LISWET11", "LISWET12",
        // STADAT family (all 3)
        "STADAT1", "STADAT2", "STADAT3",
        // QGROW family (all 3)
        "QGROW7", "QGROW15", "QGROW22",
        // Q* problems that pass with good quality
        "QETAMACR", "QISRAEL",
        "QPCBLEND", "QPCBOEI2", "QPCSTAIR",
        "QRECIPE", "QSC205",
        "QSCSD1", "QSCSD6", "QSCSD8", "QSCTAP1", "QSCTAP2", "QSCTAP3",
        "QSEBA", "QSHARE2B", "QSHELL", "QSIERRA", "QSTAIR", "QSTANDAT",
        // Other medium/large
        "DPKLO1", "DTOC3", "EXDATA", "GOULDQP2", "GOULDQP3",
        "HUES-MOD", "HUESTIS", "KSIP", "LASER",
        "MOSARQP1", "MOSARQP2", "POWELL20",
        "STCQP2", "UBH1", "VALUES", "YAO",
        // BOYD portfolio QPs (~93k vars)
        "BOYD1", "BOYD2",
    ];

    // Get expected failures list
    let expected_failures: std::collections::HashSet<&str> =
        test_problems::maros_meszaros_expected_failures().iter().copied().collect();

    for name in qps_cases {
        let is_expected_failure = expected_failures.contains(name);

        match load_local_problem(name) {
            Ok(qps) => {
                let prob = match qps.to_problem_data() {
                    Ok(p) => p,
                    Err(e) => {
                        results.push(RegressionResult {
                            name: name.to_string(),
                            status: SolveStatus::NumericalError,
                            rel_p: f64::NAN,
                            rel_d: f64::NAN,
                            gap_rel: f64::NAN,
                            iterations: 0,
                            expected_iters: None,
                            expected_status: None,
                            error: Some(format!("conversion error: {}", e)),
                            skipped: false,
                            expected_to_fail: is_expected_failure,
                            solve_time_ms: None,
                            kkt_factor_time_ms: None,
                            kkt_solve_time_ms: None,
                            cone_time_ms: None,
                        });
                        continue;
                    }
                };
                // Use reduced max_iter for expected-to-fail problems
                let mut settings_for_problem = settings.clone();
                if is_expected_failure {
                    settings_for_problem.max_iter = max_iter_fail;
                }
                let mut result = run_case(&prob, &settings_for_problem, solver, name);
                result.expected_to_fail = is_expected_failure;
                let (exp_status, exp_iters) = expected_behavior(name);
                result.expected_status = exp_status;
                result.expected_iters = exp_iters;
                results.push(result);
            }
            Err(e) => {
                if require_cache {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some(format!("missing QPS: {}", e)),
                        skipped: false,
                        expected_to_fail: is_expected_failure,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                } else {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: None,
                        skipped: true,
                        expected_to_fail: is_expected_failure,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                }
            }
        }
    }

    // Add cone problems from test_problems module
    for test_prob in test_problems::synthetic_test_problems() {
        let prob = (test_prob.builder)();
        let mut result = run_case(&prob, settings, solver, test_prob.name);
        result.expected_iters = test_prob.expected_iterations;
        results.push(result);
    }

    // SDPLIB PSD problems that currently pass with good objective accuracy.
    // These require local SDPLIB files under _data/sdplib.
    // Note: control3, control4 excluded due to ~8-9% objective error vs reference
    let sdplib_cases = [
        // Control problems (system control SDPs)
        "control1",  // rel_error ~1.6%
        "control2",  // rel_error ~0.9%
        // H-infinity norm problems
        "hinf1",
        "hinf4",     // Optimal in ~15 iters
        "hinf10",    // Optimal in ~34 iters
        "hinf11",
        "hinf14",    // Optimal in ~20 iters, rel_error 7.46e-4
        // Lovász theta (graph coloring)
        "theta1",
        // Truss topology optimization
        "truss1",    // excellent accuracy (1.34e-7 rel_error)
        "truss3",
        "truss4",
        "truss5",    // Optimal in ~27 iters, rel_error 1.66e-3
        "truss6",    // Optimal in ~24 iters, 150 3x3 blocks, rel_error 1.32e-3
        "truss7",    // Optimal in ~21 iters, 150 2x2 blocks, rel_error 1.24e-5
    ];
    let sdplib_dir = std::path::Path::new("_data/sdplib");
    if sdplib_dir.exists() {
        for name in sdplib_cases {
            let file_path = sdplib_dir.join(format!("{}.dat-s", name));
            if !file_path.exists() {
                if require_cache {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some(format!("missing SDPLIB file: {}", file_path.display())),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                } else {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: None,
                        skipped: true,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                }
                continue;
            }

            let sdpa = match sdplib::load_sdpa_file(&file_path) {
                Ok(sdpa) => sdpa,
                Err(e) => {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some(format!("sdpa parse error: {}", e)),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                    continue;
                }
            };

            let prob = match sdplib::sdpa_to_conic_selected(&sdpa) {
                Ok((prob, _form)) => prob,
                Err(e) => {
                    results.push(RegressionResult {
                        name: name.to_string(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some(format!("sdpa conversion error: {}", e)),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                    continue;
                }
            };

            let mut result = run_case(&prob, settings, solver, name);
            result.expected_iters = expected_iterations(name);
            results.push(result);
        }
    } else if require_cache {
        for name in sdplib_cases {
            results.push(RegressionResult {
                name: name.to_string(),
                status: SolveStatus::NumericalError,
                rel_p: f64::NAN,
                rel_d: f64::NAN,
                gap_rel: f64::NAN,
                iterations: 0,
                expected_iters: None,
                expected_status: None,
                error: Some("missing SDPLIB directory: _data/sdplib".to_string()),
                skipped: false,
                expected_to_fail: false,
                solve_time_ms: None,
                kkt_factor_time_ms: None,
                kkt_solve_time_ms: None,
                cone_time_ms: None,
            });
        }
    } else {
        for name in sdplib_cases {
            results.push(RegressionResult {
                name: name.to_string(),
                status: SolveStatus::NumericalError,
                rel_p: f64::NAN,
                rel_d: f64::NAN,
                gap_rel: f64::NAN,
                iterations: 0,
                expected_iters: None,
                expected_status: None,
                error: None,
                skipped: true,
                expected_to_fail: false,
                solve_time_ms: None,
                kkt_factor_time_ms: None,
                kkt_solve_time_ms: None,
                cone_time_ms: None,
            });
        }
    }

    // SOCP-reformulated QP problems (CVXPY-style without P matrix)
    // Tests SOC cone support with QP problems reformulated as SOCPs
    // Run the full MM suite as SOCPs to match CVXPY's conic form
    for name in mm_problem_names() {
        let socp_name = format!("{}_SOCP", name);
        match load_local_problem(name) {
            Ok(qps) => {
                let prob = match qps.to_socp_form() {
                    Ok(p) => p,
                    Err(e) => {
                        results.push(RegressionResult {
                            name: socp_name,
                            status: SolveStatus::NumericalError,
                            rel_p: f64::NAN,
                            rel_d: f64::NAN,
                            gap_rel: f64::NAN,
                            iterations: 0,
                            expected_iters: None,
                            expected_status: None,
                            error: Some(format!("SOCP conversion error: {}", e)),
                            skipped: false,
                            expected_to_fail: false,
                            solve_time_ms: None,
                            kkt_factor_time_ms: None,
                            kkt_solve_time_ms: None,
                            cone_time_ms: None,
                        });
                        continue;
                    }
                };
                let result = run_case(&prob, settings, solver, &socp_name);
                results.push(result);
            }
            Err(_) => {
                if require_cache {
                    results.push(RegressionResult {
                        name: socp_name,
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some("missing QPS file".to_string()),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                } else {
                    results.push(RegressionResult {
                        name: socp_name,
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: None,
                        skipped: true,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    });
                }
            }
        }
    }

    results
}

fn run_case(
    prob: &ProblemData,
    settings: &SolverSettings,
    solver: SolverChoice,
    name: &str,
) -> RegressionResult {
    match solve_with_choice(prob, settings, solver) {
        Ok(res) => {
            let n = prob.num_vars();
            let m = prob.num_constraints();
            let mut r_p = vec![0.0; m];
            let mut r_d = vec![0.0; n];
            let mut p_x = vec![0.0; n];
            let metrics = compute_unscaled_metrics(
                &prob.A,
                prob.P.as_ref(),
                &prob.q,
                &prob.b,
                &res.x,
                &res.s,
                &res.z,
                &mut r_p,
                &mut r_d,
                &mut p_x,
            );

            RegressionResult {
                name: name.to_string(),
                status: res.status,
                rel_p: metrics.rel_p,
                rel_d: metrics.rel_d,
                gap_rel: metrics.gap_rel,
                iterations: res.info.iters,
                expected_iters: None, // Will be set by caller
                expected_status: None, // Will be set by caller
                error: None,
                skipped: false,
                expected_to_fail: false, // Will be set by caller
                solve_time_ms: Some(res.info.solve_time_ms),
                kkt_factor_time_ms: Some(res.info.kkt_factor_time_ms),
                kkt_solve_time_ms: Some(res.info.kkt_solve_time_ms),
                cone_time_ms: Some(res.info.cone_time_ms),
            }
        }
        Err(e) => RegressionResult {
            name: name.to_string(),
            status: SolveStatus::NumericalError,
            rel_p: f64::NAN,
            rel_d: f64::NAN,
            gap_rel: f64::NAN,
            iterations: 0,
            expected_iters: None,
            expected_status: None,
            error: Some(e.to_string()),
            skipped: false,
            expected_to_fail: false, // Will be set by caller
            solve_time_ms: None,
            kkt_factor_time_ms: None,
            kkt_solve_time_ms: None,
            cone_time_ms: None,
        },
    }
}

/// Run SOCP-only tests with limited iterations and streaming output.
/// Uses 30 iterations as limit (SOCP reformulations typically need ~2x QP iterations).
fn run_socp_tests(
    base_settings: &SolverSettings,
    solver: SolverChoice,
    require_cache: bool,
    filter: Option<&str>,
) -> Vec<RegressionResult> {
    use std::io::Write;

    let mut results = Vec::new();

    // Use limited iterations for SOCP tests - they should converge quickly if working
    let mut settings = base_settings.clone();
    settings.max_iter = 30; // SOCP should converge in ~20 iters for well-behaved problems

    // Match Clarabel's default tolerances exactly
    let tol_feas = 1e-8;  // Clarabel default
    let tol_gap = 1e-8;   // Clarabel default
    settings.tol_feas = tol_feas;
    settings.tol_gap = tol_gap;

    for name in mm_problem_names() {
        // Apply filter if specified
        if let Some(f) = filter {
            if !name.starts_with(f) {
                continue;
            }
        }
        let socp_name = format!("{}_SOCP", name);

        let result = match load_local_problem(name) {
            Ok(qps) => {
                match qps.to_socp_form() {
                    Ok(prob) => run_case(&prob, &settings, solver, &socp_name),
                    Err(e) => RegressionResult {
                        name: socp_name.clone(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some(format!("SOCP conversion error: {}", e)),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    },
                }
            }
            Err(_) => {
                if require_cache {
                    RegressionResult {
                        name: socp_name.clone(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: Some("missing QPS file".to_string()),
                        skipped: false,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    }
                } else {
                    RegressionResult {
                        name: socp_name.clone(),
                        status: SolveStatus::NumericalError,
                        rel_p: f64::NAN,
                        rel_d: f64::NAN,
                        gap_rel: f64::NAN,
                        iterations: 0,
                        expected_iters: None,
                        expected_status: None,
                        error: None,
                        skipped: true,
                        expected_to_fail: false,
                        solve_time_ms: None,
                        kkt_factor_time_ms: None,
                        kkt_solve_time_ms: None,
                        cone_time_ms: None,
                    }
                }
            }
        };

        // Print result immediately for streaming output
        // Accept both Optimal and AlmostOptimal (for numerically challenging SOCP)
        let status_ok = matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal);
        if result.skipped {
            println!("{}: SKIP", result.name);
        } else if !status_ok
            || !result.rel_p.is_finite()
            || !result.rel_d.is_finite()
            || !result.gap_rel.is_finite()
        {
            println!(
                "{}: FAIL status={:?} rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e} {}",
                result.name,
                result.status,
                result.rel_p,
                result.rel_d,
                result.gap_rel,
                result.error.as_deref().unwrap_or(""),
            );
        } else {
            // For AlmostOptimal, use Clarabel's reduced tolerances
            let effective_tol_feas = if result.status == SolveStatus::AlmostOptimal {
                1e-4  // Clarabel's reduced_tol_feas
            } else {
                tol_feas
            };
            let effective_tol_gap = if result.status == SolveStatus::AlmostOptimal {
                5e-5  // Clarabel's reduced_tol_gap_rel
            } else {
                tol_gap
            };

            if result.rel_p > effective_tol_feas || result.rel_d > effective_tol_feas || result.gap_rel > effective_tol_gap {
                println!(
                    "{}: FAIL rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e}",
                    result.name, result.rel_p, result.rel_d, result.gap_rel,
                );
            } else {
                let status_str = if result.status == SolveStatus::AlmostOptimal { "~OK" } else { "OK" };
                println!(
                    "{}: {} iters={} rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e}",
                    result.name, status_str, result.iterations, result.rel_p, result.rel_d, result.gap_rel,
                );
            }
        }
        let _ = std::io::stdout().flush();

        results.push(result);
    }

    results
}

fn synthetic_cases() -> Vec<(&'static str, ProblemData)> {
    let mut cases = Vec::new();

    // Nonnegativity LP: min x, x >= 0
    let a = solver_core::linalg::sparse::from_triplets(1, 1, vec![(0, 0, -1.0)]);
    let prob = ProblemData {
        P: None,
        q: vec![1.0],
        A: a,
        b: vec![0.0],
        cones: vec![ConeSpec::NonNeg { dim: 1 }],
        var_bounds: None,
        integrality: None,
    };
    cases.push(("SYN_LP_NONNEG", prob));

    // SOC feasibility: x in SOC via s = x, A = -I, b = 0.
    let a = solver_core::linalg::sparse::from_triplets(
        2,
        2,
        vec![(0, 0, -1.0), (1, 1, -1.0)],
    );
    let prob = ProblemData {
        P: None,
        q: vec![0.0, 0.0],
        A: a,
        b: vec![0.0, 0.0],
        cones: vec![ConeSpec::Soc { dim: 2 }],
        var_bounds: None,
        integrality: None,
    };
    cases.push(("SYN_SOC_FEAS", prob));

    cases
}

/// Expected iterations for each problem - measured with 1e-8 tolerance (industry standard)
/// These are EXACT iteration counts with no margin/slop allowed.
fn expected_iterations(name: &str) -> Option<usize> {
    match name {
        // HS problems
        "HS21" => Some(9), "HS35" => Some(6), "HS35MOD" => Some(12),
        "HS51" => Some(4), "HS52" => Some(4), "HS53" => Some(6),
        "HS76" => Some(6), "HS118" => Some(11), "HS268" => Some(8),
        // Small problems
        "TAME" => Some(4), "S268" => Some(8), "ZECEVIC2" => Some(7),
        "LOTSCHD" => Some(8), "QAFIRO" => Some(14),
        // CVXQP family
        "CVXQP1_S" => Some(8), "CVXQP2_S" => Some(9), "CVXQP3_S" => Some(10),
        "CVXQP1_M" => Some(10), "CVXQP2_M" => Some(9), "CVXQP3_M" => Some(12),
        "CVXQP1_L" => Some(11), "CVXQP2_L" => Some(10), "CVXQP3_L" => Some(10),
        // DUAL/PRIMAL
        "DUAL1" => Some(12), "DUAL2" => Some(11), "DUAL3" => Some(12), "DUAL4" => Some(12),
        "DUALC1" => Some(13), "DUALC2" => Some(10), "DUALC5" => Some(10), "DUALC8" => Some(10),
        "PRIMAL1" => Some(10), "PRIMAL2" => Some(9), "PRIMAL3" => Some(10), "PRIMAL4" => Some(9),
        "PRIMALC1" => Some(16), "PRIMALC2" => Some(14), "PRIMALC5" => Some(9), "PRIMALC8" => Some(13),
        // AUG family
        "AUG2D" => Some(7), "AUG2DC" => Some(7), "AUG2DCQP" => Some(13), "AUG2DQP" => Some(14),
        "AUG3D" => Some(6), "AUG3DC" => Some(6), "AUG3DCQP" => Some(11), "AUG3DQP" => Some(13),
        // CONT family (updated after scale-invariant infeasibility detection)
        "CONT-050" => Some(10), "CONT-100" => Some(11), "CONT-101" => Some(10),
        "CONT-200" => Some(12), "CONT-201" => Some(10), "CONT-300" => Some(12),
        // LISWET family (all converge after recent fixes)
        "LISWET1" => Some(27), "LISWET2" => Some(18), "LISWET3" => Some(26), "LISWET4" => Some(36),
        "LISWET5" => Some(20), "LISWET6" => Some(25), "LISWET7" => Some(32), "LISWET8" => Some(32),
        "LISWET9" => Some(38), "LISWET10" => Some(25), "LISWET11" => Some(30), "LISWET12" => Some(38),
        // STADAT/QGROW
        "STADAT1" => Some(12), "STADAT2" => Some(26), "STADAT3" => Some(27),
        "QGROW7" => Some(22), "QGROW15" => Some(24), "QGROW22" => Some(28),
        // Other Q* problems
        "QETAMACR" => Some(21), "QISRAEL" => Some(27), "QPCBLEND" => Some(17),
        "QPCBOEI2" => Some(24), "QPCSTAIR" => Some(21), "QRECIPE" => Some(17),
        "QSC205" => Some(16), "QSCSD1" => Some(9), "QSCSD6" => Some(13), "QSCSD8" => Some(12),
        "QSCTAP1" => Some(19), "QSCTAP2" => Some(11), "QSCTAP3" => Some(13),
        "QSEBA" => Some(24), "QSHARE2B" => Some(17), "QSHELL" => Some(37),
        "QSIERRA" => Some(34), "QSTAIR" => Some(21), "QSTANDAT" => Some(18),
        // Other
        "DPKLO1" => Some(4), "DTOC3" => Some(5), "EXDATA" => Some(13),
        "GOULDQP2" => Some(14), "GOULDQP3" => Some(8),
        "HUES-MOD" => Some(10), "HUESTIS" => Some(10), "KSIP" => Some(12), "LASER" => Some(9),
        "MOSARQP1" => Some(10), "MOSARQP2" => Some(10), "POWELL20" => Some(9),
        "STCQP2" => Some(8), "UBH1" => Some(63), "VALUES" => Some(13), "YAO" => Some(44),
        // BOYD (large) - these hit MaxIters, no expected value
        // Synthetic (measured exact with 1e-8 tolerances)
        "SYN_LP_NONNEG" => Some(4), "SYN_SOC_FEAS" => Some(5),
        // SDPLIB SDP problems (PSD cone)
        "control1" => Some(21), "control2" => Some(26),
        "hinf1" => Some(26), "hinf4" => Some(15), "hinf10" => Some(34), "hinf11" => Some(20), "hinf14" => Some(20),
        "theta1" => Some(9),
        "truss1" => Some(8), "truss3" => Some(10), "truss4" => Some(7), "truss5" => Some(27),
        "truss6" => Some(24), "truss7" => Some(21),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    #[test]
    fn regression_suite_smoke() {
        let require_cache = env::var("MINIX_REQUIRE_QPS_CACHE")
            .ok()
            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);
        let max_iter = env::var("MINIX_REGRESSION_MAX_ITER")
            .ok()
            .and_then(|v| v.parse::<usize>().ok())
            .unwrap_or(200);
        let max_iter_fail = env::var("MINIX_REGRESSION_MAX_ITER_FAIL")
            .ok()
            .and_then(|v| v.parse::<usize>().ok())
            .unwrap_or(50);
        let verbose = env::var("MINIX_VERBOSE")
            .ok()
            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);

        let mut settings = SolverSettings::default();
        settings.max_iter = max_iter;

        let results = run_regression_suite(&settings, SolverChoice::Ipm2, require_cache, max_iter_fail);
        // Use practical tolerances for unscaled metrics
        // The solver uses scaled metrics internally (1e-8), but unscaled
        // metrics can differ due to problem conditioning.
        // Clarabel uses: tol_feas=1e-8, reduced_tol_feas=1e-4, reduced_tol_gap_rel=5e-5
        let tol_feas = 1e-6;      // Feasibility tolerance for unscaled metrics (QP/LP)
        let tol_feas_sdp = 1e-4;  // Looser tolerance for SDP (matches Clarabel's reduced_tol_feas)
        let tol_gap = 1e-4;       // Relative gap tolerance (close to Clarabel's reduced 5e-5)

        // SDPLIB problem names (for looser tolerances)
        let sdp_problems: std::collections::HashSet<&str> = [
            "control1", "control2", "hinf1", "hinf4", "hinf10", "hinf11", "hinf14",
            "theta1", "truss1", "truss3", "truss4", "truss5",
        ].iter().copied().collect();

        let mut failures = Vec::new();
        let mut unexpected_passes = Vec::new();

        for res in &results {
            if res.skipped {
                if require_cache {
                    failures.push(format!("{}: missing cache", res.name));
                }
                continue;
            }

            // Use looser tolerances for SDP problems
            let effective_tol_feas = if sdp_problems.contains(res.name.as_str()) {
                tol_feas_sdp
            } else {
                tol_feas
            };

            let is_pass = matches!(res.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal)
                && res.rel_p.is_finite()
                && res.rel_d.is_finite()
                && res.gap_rel.is_finite()
                && res.rel_p <= effective_tol_feas
                && res.rel_d <= effective_tol_feas
                && res.gap_rel <= tol_gap;

            if res.expected_to_fail {
                // Expected to fail - don't fail CI if it does
                if is_pass {
                    unexpected_passes.push(format!("🎉 {} unexpectedly passed!", res.name));
                }
                continue; // Don't check further for expected failures
            }

            // Check if expected status is set and verify it matches
            if let Some(expected_status) = &res.expected_status {
                if std::mem::discriminant(&res.status) != std::mem::discriminant(expected_status) {
                    failures.push(format!(
                        "{}: status changed from expected {:?} to {:?} (iters={})",
                        res.name, expected_status, res.status, res.iterations
                    ));
                    continue;
                }
            }

            // Check iteration count regression (only if expected_iters is set)
            if let Some(expected_iters) = res.expected_iters {
                let iter_ratio = res.iterations as f64 / expected_iters as f64;
                if iter_ratio > 1.2 {
                    failures.push(format!(
                        "{}: iteration regression {:.2}x (expected {}, got {})",
                        res.name, iter_ratio, expected_iters, res.iterations
                    ));
                }
            }

            // For problems with expected non-optimal status, don't require Optimal
            let is_expected_non_optimal = matches!(
                res.expected_status,
                Some(SolveStatus::NumericalLimit)
                    | Some(SolveStatus::PrimalInfeasible)
                    | Some(SolveStatus::DualInfeasible)
                    | Some(SolveStatus::MaxIters)
            );

            // Not expected to fail - require pass (unless expected non-optimal status)
            if !is_expected_non_optimal
                && (!matches!(res.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal)
                    || !res.rel_p.is_finite()
                    || !res.rel_d.is_finite()
                    || !res.gap_rel.is_finite())
            {
                let msg = format!(
                    "{}: status={:?} rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e} {}",
                    res.name,
                    res.status,
                    res.rel_p,
                    res.rel_d,
                    res.gap_rel,
                    res.error.as_deref().unwrap_or(""),
                );
                if verbose {
                    eprintln!("\n{}", "=".repeat(60));
                    eprintln!("FAILURE: {}", res.name);
                    eprintln!("{}", "=".repeat(60));
                    eprintln!("Status: {:?}", res.status);
                    eprintln!("Iterations: {}", res.iterations);
                    eprintln!("Metrics:");
                    eprintln!("  rel_p:   {:.2e}", res.rel_p);
                    eprintln!("  rel_d:   {:.2e}", res.rel_d);
                    eprintln!("  gap_rel: {:.2e}", res.gap_rel);
                    if let Some(t) = res.solve_time_ms {
                        eprintln!("Wall clock: {:.1} ms", t);
                    }
                    if let Some(err) = &res.error {
                        eprintln!("Error: {}", err);
                    }
                    eprintln!("{}", "=".repeat(60));
                }
                failures.push(msg);
                continue;
            }
            // Skip tolerance check for problems with expected non-optimal status
            if !is_expected_non_optimal && (res.rel_p > effective_tol_feas || res.rel_d > effective_tol_feas || res.gap_rel > tol_gap) {
                let msg = format!(
                    "{}: rel_p={:.2e} rel_d={:.2e} gap_rel={:.2e}",
                    res.name, res.rel_p, res.rel_d, res.gap_rel
                );
                if verbose {
                    eprintln!("\n{}", "=".repeat(60));
                    eprintln!("TOLERANCE FAILURE: {}", res.name);
                    eprintln!("{}", "=".repeat(60));
                    eprintln!("Status: {:?}", res.status);
                    eprintln!("Iterations: {}", res.iterations);
                    eprintln!("Metrics (exceeds tolerances):");
                    eprintln!("  rel_p:   {:.2e} (tol: {:.2e})", res.rel_p, tol_feas);
                    eprintln!("  rel_d:   {:.2e} (tol: {:.2e})", res.rel_d, tol_feas);
                    eprintln!("  gap_rel: {:.2e} (tol: {:.2e})", res.gap_rel, tol_gap);
                    if let Some(t) = res.solve_time_ms {
                        eprintln!("Wall clock: {:.1} ms", t);
                    }
                    eprintln!("{}", "=".repeat(60));
                }
                failures.push(msg);
            }
            // Check iteration count - must match exactly
            if let Some(expected) = expected_iterations(&res.name) {
                if res.iterations != expected {
                    let msg = format!(
                        "{}: iteration mismatch {} != {} (expected exact match)",
                        res.name, res.iterations, expected
                    );
                    if verbose {
                        eprintln!("\n{}", "=".repeat(60));
                        eprintln!("ITERATION MISMATCH: {}", res.name);
                        eprintln!("{}", "=".repeat(60));
                        eprintln!("Status: {:?}", res.status);
                        eprintln!("Iterations: {} (expected: {})", res.iterations, expected);
                        eprintln!("Metrics:");
                        eprintln!("  rel_p:   {:.2e}", res.rel_p);
                        eprintln!("  rel_d:   {:.2e}", res.rel_d);
                        eprintln!("  gap_rel: {:.2e}", res.gap_rel);
                        if let Some(t) = res.solve_time_ms {
                            eprintln!("Wall clock: {:.1} ms", t);
                        }
                        eprintln!("{}", "=".repeat(60));
                    }
                    failures.push(msg);
                }
            }
        }

        // Print unexpected passes (informational only, don't fail CI)
        for msg in &unexpected_passes {
            eprintln!("{}", msg);
        }

        if !failures.is_empty() {
            panic!("regression failures:\n{}", failures.join("\n"));
        }

        if let Ok(path) = env::var("MINIX_PERF_BASELINE") {
            let contents = std::fs::read_to_string(&path)
                .unwrap_or_else(|e| panic!("failed to read baseline {}: {}", path, e));
            let baseline: PerfSummary = serde_json::from_str(&contents)
                .unwrap_or_else(|e| panic!("failed to parse baseline {}: {}", path, e));
            let summary = perf_summary(&results);
            let max_regression = env::var("MINIX_MAX_REGRESSION")
                .ok()
                .and_then(|v| v.parse::<f64>().ok())
                .unwrap_or(0.2);
            let perf_failures = compare_perf_baseline(&baseline, &summary, max_regression);
            if !perf_failures.is_empty() {
                panic!("perf regression:\n{}", perf_failures.join("\n"));
            }
        }
    }
}

=== src/sdplib.rs ===
//! SDPLIB benchmark support - SDPA-sparse format parser and runner
//!
//! SDPA sparse format (.dat-s):
//! - Lines starting with " or * are comments
//! - mDim: number of constraint matrices (= primal constraints)
//! - nBlock: number of blocks
//! - blockStruct: sizes of each block (negative = diagonal block)
//! - c: objective vector (mDim values)
//! - Matrix entries: matNo blockNo i j value
//!
//! The SDP problem in SDPA format:
//! (P) max  tr(F0 * X)
//!     s.t. tr(Fi * X) = ci  for i = 1, ..., m
//!          X ⪰ 0
//!
//! (D) min  c'y
//!     s.t. F0 + sum_i yi*Fi ⪰ 0

use solver_core::{ProblemData, ConeSpec, SolverSettings, solve, SolveStatus};
use solver_core::linalg::sparse;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

/// Parsed SDPA problem
#[derive(Debug, Clone)]
pub struct SdpaData {
    pub name: String,
    pub m_dim: usize,           // Number of constraints
    pub n_block: usize,         // Number of blocks
    pub block_struct: Vec<i32>, // Block sizes (negative = diagonal)
    pub c: Vec<f64>,            // Objective coefficients
    pub matrices: Vec<SdpaMatrix>, // F0, F1, ..., Fm
}

/// Sparse matrix in SDPA format
#[derive(Debug, Clone, Default)]
pub struct SdpaMatrix {
    pub entries: Vec<SdpaEntry>,
}

/// Single entry in SDPA matrix
#[derive(Debug, Clone)]
pub struct SdpaEntry {
    pub block: usize,  // 1-indexed block number
    pub i: usize,      // 1-indexed row
    pub j: usize,      // 1-indexed column
    pub value: f64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SdpaForm {
    Primal,
    Dual,
}

fn sdpa_form_from_env() -> SdpaForm {
    match env::var("MINIX_SDPA_FORM")
        .ok()
        .as_deref()
        .map(|v| v.to_ascii_lowercase())
        .as_deref()
    {
        Some("primal") | Some("p") | Some("0") => SdpaForm::Primal,
        Some("dual") | Some("d") | Some("1") => SdpaForm::Dual,
        _ => SdpaForm::Primal,
    }
}

/// Parse SDPA sparse format file
pub fn parse_sdpa_sparse(content: &str, name: &str) -> Result<SdpaData, String> {
    let mut lines = content.lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty() && !l.starts_with('"') && !l.starts_with('*'));

    // Parse mDim
    let m_dim: usize = lines.next()
        .ok_or("Missing mDim")?
        .split_whitespace()
        .next()
        .ok_or("Empty mDim line")?
        .parse()
        .map_err(|e| format!("Invalid mDim: {}", e))?;

    // Parse nBlock
    let n_block: usize = lines.next()
        .ok_or("Missing nBlock")?
        .split_whitespace()
        .next()
        .ok_or("Empty nBlock line")?
        .parse()
        .map_err(|e| format!("Invalid nBlock: {}", e))?;

    // Parse blockStruct
    let block_line = lines.next().ok_or("Missing blockStruct")?;
    let block_struct: Vec<i32> = block_line
        .replace(['(', ')', '{', '}', ','], " ")
        .split_whitespace()
        .filter(|s| !s.is_empty())
        .map(|s| s.parse::<i32>())
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("Invalid blockStruct: {}", e))?;

    if block_struct.len() != n_block {
        return Err(format!(
            "blockStruct length {} != nBlock {}",
            block_struct.len(), n_block
        ));
    }

    // Parse c vector
    let c_line = lines.next().ok_or("Missing c vector")?;
    let c: Vec<f64> = c_line
        .replace(['(', ')', '{', '}', ','], " ")
        .split_whitespace()
        .filter(|s| !s.is_empty())
        .map(|s| s.parse::<f64>())
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("Invalid c vector: {}", e))?;

    if c.len() != m_dim {
        return Err(format!("c length {} != mDim {}", c.len(), m_dim));
    }

    // Parse matrix entries
    let mut matrices: Vec<SdpaMatrix> = (0..=m_dim).map(|_| SdpaMatrix::default()).collect();

    for line in lines {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 5 {
            continue; // Skip malformed lines
        }

        let mat_no: usize = parts[0].parse()
            .map_err(|e| format!("Invalid matNo: {}", e))?;
        let block: usize = parts[1].parse()
            .map_err(|e| format!("Invalid blockNo: {}", e))?;
        let i: usize = parts[2].parse()
            .map_err(|e| format!("Invalid i: {}", e))?;
        let j: usize = parts[3].parse()
            .map_err(|e| format!("Invalid j: {}", e))?;
        let value: f64 = parts[4].parse()
            .map_err(|e| format!("Invalid value: {}", e))?;

        if mat_no > m_dim {
            return Err(format!("matNo {} > mDim {}", mat_no, m_dim));
        }

        matrices[mat_no].entries.push(SdpaEntry { block, i, j, value });
    }

    Ok(SdpaData {
        name: name.to_string(),
        m_dim,
        n_block,
        block_struct,
        c,
        matrices,
    })
}

fn sdpa_block_offsets(sdpa: &SdpaData) -> (Vec<usize>, usize) {
    let mut block_offsets = Vec::with_capacity(sdpa.n_block + 1);
    let mut total_dim = 0usize;
    block_offsets.push(0);

    for &size in &sdpa.block_struct {
        let n = size.unsigned_abs() as usize;
        let dim = if size < 0 {
            n
        } else {
            n * (n + 1) / 2
        };
        total_dim += dim;
        block_offsets.push(total_dim);
    }

    (block_offsets, total_dim)
}

/// Convert SDPA problem to our standard conic form
///
/// SDPA primal: max tr(F0 * X) s.t. tr(Fi * X) = ci, X >= 0
/// Our form:    min q'x s.t. Ax + s = b, s in K
///
/// Conversion:
/// - x = svec(X) (decision variables)
/// - q = -svec(F0) (negative because we minimize)
/// - A_i = svec(Fi) as row i
/// - b = c
/// - K = Zero(m) x PSD(n) where Zero handles equalities
pub fn sdpa_to_conic(sdpa: &SdpaData) -> Result<ProblemData, String> {
    let (block_offsets, total_dim) = sdpa_block_offsets(sdpa);

    // Build objective q = -svec(F0)
    let mut q = vec![0.0; total_dim];
    for entry in &sdpa.matrices[0].entries {
        let offset = block_offsets[entry.block - 1];
        let block_size = sdpa.block_struct[entry.block - 1];
        let idx = svec_index(entry.i, entry.j, block_size, offset);
        let scale = svec_scale(entry.i, entry.j, block_size);
        q[idx] -= entry.value * scale; // Negative for minimization
    }

    // Build constraint matrix A
    // Each row i corresponds to constraint tr(Fi * X) = ci
    // A[i, :] = svec(Fi)
    let mut triplets = Vec::new();

    for (mat_idx, matrix) in sdpa.matrices.iter().enumerate().skip(1) {
        let row = mat_idx - 1; // F1 -> row 0, F2 -> row 1, etc.
        for entry in &matrix.entries {
            let offset = block_offsets[entry.block - 1];
            let block_size = sdpa.block_struct[entry.block - 1];
            let col = svec_index(entry.i, entry.j, block_size, offset);
            let scale = svec_scale(entry.i, entry.j, block_size);
            triplets.push((row, col, entry.value * scale));
        }
    }

    // Add PSD cone constraint: -x + s_psd = 0
    // This embeds x into the PSD cone
    for i in 0..total_dim {
        triplets.push((sdpa.m_dim + i, i, -1.0));
    }

    let a = sparse::from_triplets(sdpa.m_dim + total_dim, total_dim, triplets);

    // RHS: b = [c; 0]
    let mut b = sdpa.c.clone();
    b.extend(vec![0.0; total_dim]);

    // Cones: Zero for equalities, then PSD/diagonal blocks
    let mut cones = vec![ConeSpec::Zero { dim: sdpa.m_dim }];

    // Add PSD/diagonal cones for each block
    for &size in &sdpa.block_struct {
        if size < 0 {
            // Diagonal block -> NonNeg cone
            let n = size.unsigned_abs() as usize;
            cones.push(ConeSpec::NonNeg { dim: n });
        } else {
            // Dense PSD block
            let n = size as usize;
            cones.push(ConeSpec::Psd { n });
        }
    }

    Ok(ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    })
}

/// Convert SDPA problem to the dual conic form.
///
/// SDPA dual: min c'y s.t. F0 - sum_i y_i Fi >= 0
/// Our form:  min q'y s.t. A y + s = b, s in K
///
/// Conversion:
/// - y = dual variables (length m)
/// - q = c
/// - b = svec(F0)
/// - A[:, i] = -svec(Fi) for i=1..m
/// - K = PSD blocks (no Zero cone)
pub fn sdpa_to_conic_dual(sdpa: &SdpaData) -> Result<ProblemData, String> {
    let (block_offsets, total_dim) = sdpa_block_offsets(sdpa);

    let q = sdpa.c.clone();

    let mut b = vec![0.0; total_dim];
    for entry in &sdpa.matrices[0].entries {
        let offset = block_offsets[entry.block - 1];
        let block_size = sdpa.block_struct[entry.block - 1];
        let idx = svec_index(entry.i, entry.j, block_size, offset);
        let scale = svec_scale(entry.i, entry.j, block_size);
        b[idx] += entry.value * scale;
    }

    let mut triplets = Vec::new();
    for (mat_idx, matrix) in sdpa.matrices.iter().enumerate().skip(1) {
        let col = mat_idx - 1;
        for entry in &matrix.entries {
            let offset = block_offsets[entry.block - 1];
            let block_size = sdpa.block_struct[entry.block - 1];
            let row = svec_index(entry.i, entry.j, block_size, offset);
            let scale = svec_scale(entry.i, entry.j, block_size);
            // Negate: A[:, i] = -svec(Fi) for the dual form
            triplets.push((row, col, -entry.value * scale));
        }
    }
    let a = sparse::from_triplets(total_dim, sdpa.m_dim, triplets);

    let mut cones = Vec::new();
    for &size in &sdpa.block_struct {
        if size < 0 {
            let n = size.unsigned_abs() as usize;
            cones.push(ConeSpec::NonNeg { dim: n });
        } else {
            let n = size as usize;
            cones.push(ConeSpec::Psd { n });
        }
    }

    Ok(ProblemData {
        P: None,
        q,
        A: a,
        b,
        cones,
        var_bounds: None,
        integrality: None,
    })
}

pub fn sdpa_to_conic_selected(sdpa: &SdpaData) -> Result<(ProblemData, SdpaForm), String> {
    let form = sdpa_form_from_env();
    let prob = match form {
        SdpaForm::Primal => sdpa_to_conic(sdpa)?,
        SdpaForm::Dual => sdpa_to_conic_dual(sdpa)?,
    };
    Ok((prob, form))
}

/// Compute svec index for (i, j) entry in a block
fn svec_index(i: usize, j: usize, block_size: i32, offset: usize) -> usize {
    let (i, j) = if i <= j { (i, j) } else { (j, i) };
    let i = i - 1; // Convert to 0-indexed
    let j = j - 1;

    if block_size < 0 {
        // Diagonal block: just use i (should have i == j)
        offset + i
    } else {
        // Dense block: upper triangular column-major
        // Index = j*(j+1)/2 + i for i <= j
        offset + j * (j + 1) / 2 + i
    }
}

/// Compute svec scaling factor for (i, j) entry
fn svec_scale(i: usize, j: usize, block_size: i32) -> f64 {
    if block_size < 0 {
        // Diagonal block: no scaling
        1.0
    } else if i == j {
        // Diagonal: no scaling
        1.0
    } else {
        // Off-diagonal: sqrt(2) scaling for svec
        std::f64::consts::SQRT_2
    }
}

/// Load SDPA problem from file
pub fn load_sdpa_file(path: &Path) -> Result<SdpaData, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let name = path.file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("unknown")
        .to_string();

    parse_sdpa_sparse(&content, &name)
}

/// Solve an SDPA problem and return results
pub fn solve_sdpa(sdpa: &SdpaData, settings: &SolverSettings) -> Result<SdpaResult, String> {
    let (prob, form) = sdpa_to_conic_selected(sdpa)?;


    let result = solve(&prob, settings)
        .map_err(|e| format!("Solve failed: {}", e))?;


    let sdpa_obj = match form {
        SdpaForm::Primal => {
            // Our solver minimizes q'x. SDPA maximizes tr(F0 * X).
            // Since q = -svec(F0), our obj_val = -tr(F0 * X)
            -result.obj_val
        }
        SdpaForm::Dual => {
            // Dual form minimizes c^T y, which matches the primal optimum.
            result.obj_val
        }
    };

    Ok(SdpaResult {
        name: sdpa.name.clone(),
        status: result.status,
        primal_obj: sdpa_obj,
        dual_obj: sdpa_obj, // At optimality, primal = dual
        iterations: result.info.iters,
        solve_time_ms: result.info.solve_time_ms as f64,
    })
}

/// Result of solving an SDPA problem
#[derive(Debug, Clone)]
pub struct SdpaResult {
    pub name: String,
    pub status: SolveStatus,
    pub primal_obj: f64,
    pub dual_obj: f64,
    pub iterations: usize,
    pub solve_time_ms: f64,
}

/// Known SDPLIB problems with their expected optimal values
pub fn sdplib_reference_values() -> HashMap<&'static str, f64> {
    let mut map = HashMap::new();

    // Control theory problems
    map.insert("control1", 1.778463e+01);
    map.insert("control2", 8.300000e+00);
    map.insert("control3", 1.363327e+01);
    map.insert("control4", 1.979423e+01);
    map.insert("control5", 3.872609e+01);
    map.insert("control6", 3.693280e+01);
    map.insert("control7", 2.062507e+01);
    map.insert("control8", 2.028857e+01);
    map.insert("control9", 1.465544e+01);
    map.insert("control10", 3.812901e+01);
    map.insert("control11", 3.197364e+01);

    // Truss topology design (from SDPLIB GitHub: https://github.com/vsdp/SDPLIB)
    map.insert("truss1", -8.999996e+00);
    map.insert("truss2", -1.233804e+02);
    map.insert("truss3", -9.109996e+00);
    map.insert("truss4", -9.009996e+00);
    map.insert("truss5", -1.326357e+02);  // Fixed: was -1.323968e+02
    map.insert("truss6", -9.01001e+02);   // Fixed: was -9.009996e+00, actual is ~-901
    map.insert("truss7", -9.00001e+02);   // Fixed: was -9.009996e+00, actual is ~-900
    map.insert("truss8", -1.331146e+02);  // Fixed: was -1.331145e+02

    // Graph theta problems
    map.insert("theta1", 2.300000e+01);
    map.insert("theta2", 3.287917e+01);
    map.insert("theta3", 4.216739e+01);
    map.insert("theta4", 5.032116e+01);
    map.insert("theta5", 5.723231e+01);
    map.insert("theta6", 6.348335e+01);

    // Max-cut problems
    map.insert("maxG11", -6.291546e+02);
    map.insert("maxG32", -1.567645e+03);
    map.insert("maxG51", -4.003809e+03);

    // Quadratic assignment
    map.insert("qap5", 4.360000e+02);
    map.insert("qap6", 3.810000e+02);
    map.insert("qap7", 4.240000e+02);
    map.insert("qap8", 7.560000e+02);
    map.insert("qap9", 1.410000e+03);
    map.insert("qap10", 1.094000e+03);

    // Minimum bisection
    map.insert("mcp100", 2.261574e+01);
    map.insert("mcp124-1", 1.419981e+01);
    map.insert("mcp124-2", 2.700017e+01);
    map.insert("mcp124-3", 4.677320e+01);
    map.insert("mcp124-4", 1.642999e+02);
    map.insert("mcp250-1", 3.172659e+01);
    map.insert("mcp250-2", 5.347332e+01);
    map.insert("mcp250-3", 9.681225e+01);
    map.insert("mcp250-4", 3.519997e+02);
    map.insert("mcp500-1", 6.214022e+01);
    map.insert("mcp500-2", 1.073149e+02);
    map.insert("mcp500-3", 1.962579e+02);
    map.insert("mcp500-4", 7.179996e+02);

    // Goemans-Williamson
    map.insert("gpp100", -4.494637e+01);
    map.insert("gpp124-1", -7.143998e+00);
    map.insert("gpp124-2", -4.068617e+01);
    map.insert("gpp124-3", -1.536847e+02);
    map.insert("gpp124-4", -4.199997e+02);
    map.insert("gpp250-1", -1.544997e+01);
    map.insert("gpp250-2", -8.183848e+01);
    map.insert("gpp250-3", -3.046476e+02);
    map.insert("gpp250-4", -8.509993e+02);
    map.insert("gpp500-1", -2.530000e+01);
    map.insert("gpp500-2", -1.562997e+02);
    map.insert("gpp500-3", -6.285432e+02);
    map.insert("gpp500-4", -1.737999e+03);

    // Equalizer design
    map.insert("equalG11", 6.291546e+02);
    map.insert("equalG32", 1.567645e+03);
    map.insert("equalG51", 4.003809e+03);

    // Random problems
    map.insert("hinf1", 2.032749e+00);
    map.insert("hinf2", 1.093083e+01);
    map.insert("hinf3", 5.695699e+01);
    map.insert("hinf4", 2.741482e+02);
    map.insert("hinf5", 3.627673e+02);
    map.insert("hinf6", 4.490119e+02);
    map.insert("hinf7", 3.905606e+02);
    map.insert("hinf8", 1.169094e+02);
    map.insert("hinf9", 2.364919e+02);
    map.insert("hinf10", 1.089917e+02);
    map.insert("hinf11", 6.590448e+01);
    map.insert("hinf12", 2.000000e-01);
    map.insert("hinf13", 4.565385e+01);
    map.insert("hinf14", 1.299996e+01);
    map.insert("hinf15", 2.440000e+01);

    // Sensor network localization
    map.insert("arch0", 5.66517e-01);
    map.insert("arch2", 6.71515e-01);
    map.insert("arch4", 9.32645e-01);
    map.insert("arch8", 7.05698e+00);

    // Toeplitz
    map.insert("taha1a", 9.95583e+06);
    map.insert("taha1b", 1.41211e+07);

    map
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_sdpa() {
        // Simple 2x2 SDP example
        let content = r#"
* Example problem
2
1
2
1.0 2.0
0 1 1 1 1.0
0 1 2 2 1.0
1 1 1 1 1.0
1 1 1 2 0.5
1 1 2 2 0.0
2 1 1 1 0.0
2 1 1 2 0.5
2 1 2 2 1.0
"#;
        let sdpa = parse_sdpa_sparse(content, "test").unwrap();
        assert_eq!(sdpa.m_dim, 2);
        assert_eq!(sdpa.n_block, 1);
        assert_eq!(sdpa.block_struct, vec![2]);
        assert_eq!(sdpa.c, vec![1.0, 2.0]);
        assert_eq!(sdpa.matrices[0].entries.len(), 2); // F0
        assert_eq!(sdpa.matrices[1].entries.len(), 3); // F1
        assert_eq!(sdpa.matrices[2].entries.len(), 3); // F2
    }

    #[test]
    fn test_sdpa_to_conic_simple() {
        // Simple trace minimization in SDPA form
        // max tr(I * X) s.t. tr(I * X) = 1, X >= 0
        // This is: max 1 s.t. X_11 + X_22 = 1
        let content = r#"
1
1
2
1.0
0 1 1 1 1.0
0 1 2 2 1.0
1 1 1 1 1.0
1 1 2 2 1.0
"#;
        let sdpa = parse_sdpa_sparse(content, "trace").unwrap();
        let prob = sdpa_to_conic(&sdpa).unwrap();

        // Should have 3 variables (2x2 svec: X11, X12, X22)
        assert_eq!(prob.q.len(), 3);

        // Solve it
        let mut settings = SolverSettings::default();
        settings.max_iter = 100;
        let result = solve(&prob, &settings).unwrap();

        println!("Status: {:?}", result.status);
        println!("Obj: {}", result.obj_val);

        // Optimal is X = 0.5*I, trace = 1, obj = -1 (we minimize -trace)
        assert!(matches!(result.status, SolveStatus::Optimal | SolveStatus::AlmostOptimal));
    }

    #[test]
    fn test_svec_index() {
        // Test svec indexing for 3x3 block
        // Upper triangular column-major: (1,1), (1,2), (2,2), (1,3), (2,3), (3,3)
        // Indices:                         0,     1,     2,     3,     4,     5
        assert_eq!(svec_index(1, 1, 3, 0), 0);
        assert_eq!(svec_index(1, 2, 3, 0), 1);
        assert_eq!(svec_index(2, 2, 3, 0), 2);
        assert_eq!(svec_index(1, 3, 3, 0), 3);
        assert_eq!(svec_index(2, 3, 3, 0), 4);
        assert_eq!(svec_index(3, 3, 3, 0), 5);

        // Test with offset
        assert_eq!(svec_index(1, 1, 3, 10), 10);
        assert_eq!(svec_index(2, 3, 3, 10), 14);
    }
}

=== src/solver_choice.rs ===
use clap::ValueEnum;
use solver_core::{ProblemData, SolveResult, SolverSettings};
use solver_core::ipm::solve_ipm;
use solver_core::ipm2::solve_ipm2;

#[derive(ValueEnum, Clone, Copy, Debug)]
pub enum SolverChoice {
    Ipm1,
    Ipm2,
}

pub fn solve_with_choice(
    prob: &ProblemData,
    settings: &SolverSettings,
    choice: SolverChoice,
) -> Result<SolveResult, Box<dyn std::error::Error>> {
    match choice {
        SolverChoice::Ipm1 => solve_ipm(prob, settings),
        SolverChoice::Ipm2 => solve_ipm2(prob, settings),
    }
}

=== src/test_problems.rs ===
//! Shared test problem definitions for regression and benchmarking.

use solver_core::{ConeSpec, ProblemData};

/// Test problem definition.
#[derive(Clone)]
pub struct TestProblem {
    pub name: &'static str,
    pub problem_class: &'static str,
    pub builder: fn() -> ProblemData,
    pub expected_iterations: Option<usize>,
    pub expected_wallclock_ms: Option<f64>,
    pub expected_to_fail: bool,
    pub source: &'static str,
}

// ============================================================================
// Synthetic LP/SOC Problems
// ============================================================================

fn build_syn_lp_nonneg() -> ProblemData {
    let a = solver_core::linalg::sparse::from_triplets(1, 1, vec![(0, 0, -1.0)]);
    ProblemData {
        P: None,
        q: vec![1.0],
        A: a,
        b: vec![0.0],
        cones: vec![ConeSpec::NonNeg { dim: 1 }],
        var_bounds: None,
        integrality: None,
    }
}

fn build_syn_soc_feas() -> ProblemData {
    let a = solver_core::linalg::sparse::from_triplets(
        2,
        2,
        vec![(0, 0, -1.0), (1, 1, -1.0)],
    );
    ProblemData {
        P: None,
        q: vec![0.0, 0.0],
        A: a,
        b: vec![0.0, 0.0],
        cones: vec![ConeSpec::Soc { dim: 2 }],
        var_bounds: None,
        integrality: None,
    }
}

// TODO: Add real-world SDP and exponential cone problems

// ============================================================================
// Problem Registry
// ============================================================================

pub fn synthetic_test_problems() -> Vec<TestProblem> {
    vec![
        TestProblem {
            name: "SYN_LP_NONNEG",
            problem_class: "LP",
            builder: build_syn_lp_nonneg,
            expected_iterations: Some(5),
            expected_wallclock_ms: None,
            expected_to_fail: false,
            source: "synthetic",
        },
        TestProblem {
            name: "SYN_SOC_FEAS",
            problem_class: "SOCP",
            builder: build_syn_soc_feas,
            expected_iterations: Some(9),
            expected_wallclock_ms: None,
            expected_to_fail: false,
            source: "synthetic",
        },
        // TODO: Add real-world SDP and exponential cone problems
    ]
}

pub fn maros_meszaros_problem_names() -> &'static [&'static str] {
    &[
        // HS problems (tiny)
        "HS21", "HS35", "HS35MOD", "HS51", "HS52", "HS53", "HS76", "HS118", "HS268",
        // Other tiny (<1ms)
        "TAME", "S268", "ZECEVIC2", "LOTSCHD", "QAFIRO",
        // CVXQP family (all 9)
        "CVXQP1_S", "CVXQP2_S", "CVXQP3_S",
        "CVXQP1_M", "CVXQP2_M", "CVXQP3_M",
        "CVXQP1_L", "CVXQP2_L", "CVXQP3_L",
        // DUAL/PRIMAL families (all 16)
        "DUAL1", "DUAL2", "DUAL3", "DUAL4",
        "DUALC1", "DUALC2", "DUALC5", "DUALC8",
        "PRIMAL1", "PRIMAL2", "PRIMAL3", "PRIMAL4",
        "PRIMALC1", "PRIMALC2", "PRIMALC5", "PRIMALC8",
        // AUG family (all 8)
        "AUG2D", "AUG2DC", "AUG2DCQP", "AUG2DQP",
        "AUG3D", "AUG3DC", "AUG3DCQP", "AUG3DQP",
        // CONT family (all 6)
        "CONT-050", "CONT-100", "CONT-101", "CONT-200", "CONT-201", "CONT-300",
        // LISWET family (all 12)
        "LISWET1", "LISWET2", "LISWET3", "LISWET4", "LISWET5", "LISWET6",
        "LISWET7", "LISWET8", "LISWET9", "LISWET10", "LISWET11", "LISWET12",
        // STADAT family (all 3)
        "STADAT1", "STADAT2", "STADAT3",
        // QGROW family (all 3)
        "QGROW7", "QGROW15", "QGROW22",
        // Q* problems that pass with good quality
        "QETAMACR", "QISRAEL",
        "QPCBLEND", "QPCBOEI2", "QPCSTAIR",
        "QRECIPE", "QSC205",
        "QSCSD1", "QSCSD6", "QSCSD8", "QSCTAP1", "QSCTAP2", "QSCTAP3",
        "QSEBA", "QSHARE2B", "QSHELL", "QSIERRA", "QSTAIR", "QSTANDAT",
        // Other medium/large
        "DPKLO1", "DTOC3", "EXDATA", "GOULDQP2", "GOULDQP3",
        "HUES-MOD", "HUESTIS", "KSIP", "LASER",
        "MOSARQP1", "MOSARQP2", "POWELL20",
        "STCQP2", "UBH1", "VALUES", "YAO",
    ]
}

pub fn maros_meszaros_expected_failures() -> &'static [&'static str] {
    &[
        // BOYD1/BOYD2: Hit numerical precision floor (NumericalLimit status)
        // - κ(K) = 4.1e20 (ill-conditioned)
        // - 135,000x cancellation in A^T*z
        // - rel_p ≈ 1e-14 ✓, gap_rel ≈ 1e-6 ✓, but rel_d stuck at ~1e-3
        "BOYD1", "BOYD2",

        // QFORPLAN: Fundamental convergence failure
        // - gap_rel stuck at 97.5% (not converging)
        // - Mu oscillating (1e21 to 1e26) instead of decreasing
        // - HSDE showing infeasibility signals (different from BOYD)
        "QFORPLAN",
    ]
}
